<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lamp Robot Animation</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            overflow: hidden;
            height: 100vh;
            color: #e0e0e0;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .info {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(20, 20, 35, 0.3);
            backdrop-filter: blur(15px) saturate(180%);
            padding: 16px 20px;
            border-radius: 16px;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 2px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.08);
            z-index: 1000;
            max-width: 280px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .info h1 {
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 6px;
            letter-spacing: -0.01em;
        }

        .info p {
            font-size: 14px;
            color: #b0b0b0;
            line-height: 1.5;
            margin: 0;
        }

        .info .feature {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 12px;
            color: #c0c0c0;
        }

        .info .feature::before {
            content: '•';
            color: #64ffda;
            font-weight: bold;
            margin-right: 8px;
        }

        .controls {
            position: absolute;
            bottom: 16px;
            right: 16px;
            background: rgba(20, 20, 35, 0.25);
            backdrop-filter: blur(20px) saturate(180%);
            padding: 20px;
            border-radius: 20px;
            box-shadow:
                0 12px 40px rgba(0, 0, 0, 0.4),
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.08);
            z-index: 1000;
            width: 380px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .controls:hover {
            transform: translateY(-3px);
            background: rgba(20, 20, 35, 0.35);
            box-shadow:
                0 20px 60px rgba(0, 0, 0, 0.5),
                0 8px 24px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        .controls h4 {
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 20px;
            letter-spacing: -0.01em;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section:last-child {
            margin-bottom: 0;
        }

        .section-label {
            font-size: 12px;
            font-weight: 500;
            color: #a0a0a0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .control-row {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }

        .btn {
            flex: 1;
            background: linear-gradient(135deg, #00bcd4, #009688);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 188, 212, 0.3);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
            transition: left 0.5s;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(0, 188, 212, 0.4);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:active {
            transform: translateY(0);
            transition: transform 0.1s;
        }

        .btn:disabled {
            background: #3a3a3a;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #37474f, #455a64);
            box-shadow: 0 2px 8px rgba(55, 71, 79, 0.3);
        }

        .btn-secondary:hover {
            box-shadow: 0 4px 16px rgba(55, 71, 79, 0.4);
        }

        .frame-control {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.05),
                0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .frame-control-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 12px;
        }

        .frame-label {
            font-size: 12px;
            font-weight: 500;
            color: #a0a0a0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .frame-value {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            background: rgba(0, 188, 212, 0.2);
            padding: 4px 12px;
            border-radius: 20px;
            border: 1px solid rgba(0, 188, 212, 0.3);
            min-width: 50px;
            text-align: center;
        }

        .frame-slider {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            position: relative;
        }

        .frame-slider::-webkit-slider-track {
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
        }

        .frame-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00bcd4, #009688);
            cursor: pointer;
            box-shadow:
                0 2px 8px rgba(0, 188, 212, 0.3),
                0 0 0 0px rgba(0, 188, 212, 0.2);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .frame-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow:
                0 4px 12px rgba(0, 188, 212, 0.4),
                0 0 0 8px rgba(0, 188, 212, 0.1);
        }

        .frame-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00bcd4, #009688);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 188, 212, 0.3);
        }

        .status {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(8px);
            color: #b0b0b0;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.06);
            margin-top: 16px;
            text-align: center;
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.04),
                0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .status.success {
            background: rgba(0, 150, 136, 0.15);
            color: #64ffda;
            border-color: rgba(100, 255, 218, 0.2);
            box-shadow:
                inset 0 1px 0 rgba(100, 255, 218, 0.1),
                0 0 20px rgba(100, 255, 218, 0.1);
        }

        .status.error {
            background: rgba(244, 67, 54, 0.15);
            color: #ff8a80;
            border-color: rgba(255, 138, 128, 0.2);
            box-shadow:
                inset 0 1px 0 rgba(255, 138, 128, 0.1),
                0 0 20px rgba(255, 138, 128, 0.1);
        }

        /* Loading animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .loading {
            animation: pulse 2s infinite;
        }

        /* Floating animation for glass panels */
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-2px) rotate(0.5deg); }
            66% { transform: translateY(2px) rotate(-0.5deg); }
        }

        .info {
            animation: float 6s ease-in-out infinite;
        }

        .controls {
            animation: float 8s ease-in-out infinite reverse;
        }

        /* Property Values Panel */
        .property-values {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: rgba(20, 20, 35, 0.25);
            backdrop-filter: blur(20px) saturate(180%);
            padding: 16px 20px;
            border-radius: 20px;
            box-shadow:
                0 12px 40px rgba(0, 0, 0, 0.4),
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.08);
            z-index: 1000;
            min-width: 280px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: float 10s ease-in-out infinite;
        }

        .property-values:hover {
            transform: translateY(-3px);
            background: rgba(20, 20, 35, 0.35);
            box-shadow:
                0 20px 60px rgba(0, 0, 0, 0.5),
                0 8px 24px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        .property-values h4 {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 12px;
            letter-spacing: -0.01em;
            text-align: center;
        }

        .property-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .property-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.05),
                0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .property-label {
            font-size: 12px;
            font-weight: 500;
            color: #c0c0c0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .property-value {
            font-size: 13px;
            font-weight: 600;
            color: #ffffff;
            background: rgba(0, 188, 212, 0.2);
            padding: 3px 10px;
            border-radius: 16px;
            border: 1px solid rgba(0, 188, 212, 0.3);
            min-width: 50px;
            text-align: center;
            transition: all 0.2s ease;
        }

        /* Drag and Drop Overlay */
        .drop-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .drop-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .drop-zone {
            background: rgba(20, 20, 35, 0.9);
            backdrop-filter: blur(20px) saturate(180%);
            border: 3px dashed rgba(0, 188, 212, 0.6);
            border-radius: 24px;
            padding: 60px 80px;
            text-align: center;
            box-shadow:
                0 20px 60px rgba(0, 0, 0, 0.5),
                0 8px 24px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transform: scale(0.8);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: dropPulse 2s ease-in-out infinite;
        }

        .drop-overlay.show .drop-zone {
            transform: scale(1);
        }

        .drop-zone.drag-over {
            border-color: #64ffda;
            background: rgba(0, 188, 212, 0.1);
            transform: scale(1.05);
            animation: none;
            box-shadow:
                0 30px 80px rgba(0, 188, 212, 0.3),
                0 12px 32px rgba(0, 188, 212, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 0 40px rgba(100, 255, 218, 0.3);
        }

        .drop-icon {
            font-size: 64px;
            margin-bottom: 16px;
            animation: bounce 1s ease-in-out infinite alternate;
        }

        .drop-text {
            font-size: 24px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 8px;
            letter-spacing: -0.01em;
        }

        .drop-subtext {
            font-size: 14px;
            color: #b0b0b0;
            font-weight: 400;
        }

        @keyframes dropPulse {
            0%, 100% {
                border-color: rgba(0, 188, 212, 0.6);
                box-shadow:
                    0 20px 60px rgba(0, 0, 0, 0.5),
                    0 8px 24px rgba(0, 0, 0, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }
            50% {
                border-color: rgba(0, 188, 212, 0.8);
                box-shadow:
                    0 20px 60px rgba(0, 0, 0, 0.5),
                    0 8px 24px rgba(0, 0, 0, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1),
                    0 0 30px rgba(0, 188, 212, 0.2);
            }
        }

        @keyframes bounce {
            0% { transform: translateY(0px); }
            100% { transform: translateY(-8px); }
        }

                /* Responsive design */
        @media (max-width: 768px) {
            .info {
                top: 12px;
                left: 12px;
                right: 12px;
                max-width: none;
                padding: 12px 16px;
            }

            .controls {
                bottom: 12px;
                right: 12px;
                left: auto;
                width: auto;
                max-width: calc(100vw - 24px);
                padding: 16px;
            }

            .property-values {
                bottom: 12px;
                left: 12px;
                right: auto;
                min-width: auto;
                width: auto;
                max-width: calc(100vw - 24px);
            }

            .control-row {
                flex-direction: column;
            }

            .property-grid {
                grid-template-columns: 1fr 1fr 1fr;
                gap: 6px;
            }

            .property-item {
                flex-direction: column;
                gap: 4px;
                text-align: center;
                padding: 6px 8px;
            }

            .property-label {
                font-size: 10px;
                justify-content: center;
            }

            .property-value {
                font-size: 11px;
                padding: 2px 8px;
                min-width: 40px;
            }
        }

        /* Prevent overlap on medium screens */
        @media (max-width: 1200px) {
            .controls {
                width: 320px;
            }

            .info {
                max-width: 250px;
            }

            .property-values {
                min-width: 240px;
            }
        }

        /* Focus states for accessibility */
        .btn:focus,
        .frame-slider:focus {
            outline: 2px solid #00bcd4;
            outline-offset: 2px;
        }

        /* Schema Modal */
        .schema-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .schema-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .schema-content {
            background: rgba(20, 20, 35, 0.95);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 24px;
            padding: 32px;
            box-shadow:
                0 30px 80px rgba(0, 0, 0, 0.6),
                0 12px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.12);
            max-width: 90vw;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transform: scale(0.8);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .schema-modal.show .schema-content {
            transform: scale(1);
        }

        .schema-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .schema-title {
            font-size: 24px;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
            letter-spacing: -0.01em;
        }

        .schema-close {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
            border-radius: 12px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .schema-close:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .schema-body {
            flex: 1;
            overflow-y: auto;
            margin: 0;
            padding: 0;
        }

        .schema-json {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.6;
            color: #e0e0e0;
            white-space: pre-wrap;
            overflow-x: auto;
            max-height: 60vh;
            overflow-y: auto;
        }

        .schema-readable {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 0;
            max-height: 65vh;
            overflow-y: auto;
        }

        .schema-section {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .schema-section:last-child {
            border-bottom: none;
        }

        .schema-section-header {
            background: rgba(255, 255, 255, 0.05);
            padding: 16px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
            border-radius: 16px 16px 0 0;
        }

        .schema-section:not(:first-child) .schema-section-header {
            border-radius: 0;
        }

        .schema-section:last-child .schema-section-header {
            border-radius: 0 0 16px 16px;
        }

        .schema-section.expanded:last-child .schema-section-header {
            border-radius: 0;
        }

        .schema-section-header:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .schema-section-title {
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }

        .schema-section-toggle {
            font-size: 14px;
            color: #00bcd4;
            transition: transform 0.2s ease;
        }

        .schema-section.expanded .schema-section-toggle {
            transform: rotate(90deg);
        }

        .schema-section-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .schema-section.expanded .schema-section-content {
            max-height: 1000px;
        }

        .schema-section-body {
            padding: 20px;
        }

        .schema-property {
            margin-bottom: 16px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            border-left: 3px solid #00bcd4;
        }

        .schema-property-name {
            font-size: 14px;
            font-weight: 600;
            color: #64ffda;
            margin-bottom: 6px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }

        .schema-property-type {
            font-size: 12px;
            color: #f78c6c;
            background: rgba(247, 140, 108, 0.1);
            padding: 2px 8px;
            border-radius: 8px;
            display: inline-block;
            margin-bottom: 6px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }

        .schema-property-desc {
            font-size: 13px;
            color: #c0c0c0;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .schema-property-range {
            font-size: 12px;
            color: #c3e88d;
            background: rgba(195, 232, 141, 0.1);
            padding: 4px 8px;
            border-radius: 8px;
            display: inline-block;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }

        .schema-property-required {
            font-size: 11px;
            color: #ff9cac;
            background: rgba(255, 156, 172, 0.1);
            padding: 2px 6px;
            border-radius: 6px;
            display: inline-block;
            margin-left: 8px;
            font-weight: 500;
        }

        .schema-keyframe-example {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-top: 8px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .schema-view-toggle {
            margin-top: 16px;
            text-align: center;
        }

        .toggle-view-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
            border-radius: 8px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .toggle-view-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }



        /* Animation Editor Iframe Modal */
        .editor-iframe-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 10px;
            box-sizing: border-box;
        }

        .editor-iframe-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .editor-iframe-content {
            background: rgba(15, 15, 25, 0.95);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            width: calc(100vw - 20px);
            height: calc(100vh - 20px);
            max-width: none;
            max-height: none;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6);
        }

        .editor-iframe-modal.show .editor-iframe-content {
            transform: scale(1);
        }

        .editor-iframe-header {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            min-height: 60px;
        }

        .editor-iframe-title {
            font-size: 20px;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }

        .editor-iframe-close {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
            border-radius: 8px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .editor-iframe-close:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .editor-iframe-body {
            flex: 1;
            overflow: hidden;
            position: relative;
            min-height: 0; /* Allow flexbox to shrink if needed */
        }

        .editor-iframe-body iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: transparent;
            display: block; /* Remove any inline spacing */
        }

        /* Animation Editor */
        .editor-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .editor-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .editor-content {
            background: rgba(15, 15, 25, 0.95);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            width: 95vw;
            height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transform: scale(0.9);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6);
        }

        .editor-modal.show .editor-content {
            transform: scale(1);
        }

        .editor-header {
            background: rgba(255, 255, 255, 0.05);
            padding: 16px 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-title {
            font-size: 20px;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }

        .editor-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .editor-close {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
            border-radius: 8px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .editor-close:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .editor-body {
            flex: 1;
            display: flex;
            overflow: hidden;
            min-height: 0;
        }

        .editor-timeline {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(10, 10, 20, 0.8);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 0;
            overflow: hidden;
        }

        .timeline-header {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .timeline-config {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .config-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .config-label {
            font-size: 12px;
            color: #a0a0a0;
            font-weight: 500;
        }

        .config-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 4px 8px;
            color: #ffffff;
            font-size: 12px;
            width: 60px;
        }

        .timeline-ruler {
            background: rgba(0, 0, 0, 0.3);
            height: 30px;
            position: relative;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            overflow-x: auto;
            width: 100%;
        }

        .ruler-marks {
            height: 100%;
            position: relative;
            min-width: 100%;
        }

        .frame-mark {
            position: absolute;
            top: 0;
            bottom: 0;
            border-left: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: flex-end;
            padding-bottom: 4px;
        }

        .frame-number {
            font-size: 10px;
            color: #888;
            margin-left: 2px;
        }

        .timeline-tracks {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
            position: relative;
        }

        .property-track {
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            min-height: 60px;
            display: flex;
        }

        .track-label {
            width: 120px;
            background: rgba(255, 255, 255, 0.03);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 500;
            color: #ffffff;
        }

        .track-name {
            font-size: 13px;
            font-weight: 500;
            color: #ffffff;
            margin-bottom: 2px;
        }

        .track-value {
            font-size: 11px;
            font-weight: 600;
            color: #64ffda;
            background: rgba(100, 255, 218, 0.15);
            padding: 2px 6px;
            border-radius: 8px;
            text-align: center;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            width: fit-content;
        }

        .track-timeline {
            flex: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.2);
            cursor: crosshair;
        }

        .keyframe {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #00bcd4;
            border: 2px solid #ffffff;
            border-radius: 50%;
            cursor: grab;
            transform: translate(-50%, -50%);
            top: 50%;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .keyframe:hover {
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 0 0 10px rgba(0, 188, 212, 0.5);
        }

        .keyframe.selected {
            background: #ff9800;
            box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
        }

        .keyframe:active {
            cursor: grabbing;
        }

        .playhead {
            position: absolute;
            top: 0;
            width: 2px;
            background: #ff4444;
            z-index: 100;
            height: 100%;
            cursor: ew-resize;
        }

        .playhead-handle {
            position: absolute;
            top: 4px;
            left: -6px;
            width: 12px;
            height: 12px;
            background: #ff4444;
            border: 2px solid #ffffff;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px rgba(255, 68, 68, 0.5);
            z-index: 101;
        }

        .playhead-handle:active {
            cursor: grabbing;
        }

        .playhead-frame-display {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
            margin-bottom: 8px;
            border: 1px solid #ff4444;
            z-index: 102;
        }

        .playhead::before {
            content: '';
            position: absolute;
            top: -6px;
            left: -4px;
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 6px solid #ff4444;
        }

        .editor-sidebar {
            width: 300px;
            min-width: 300px;
            max-width: 300px;
            background: rgba(20, 20, 35, 0.9);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .sidebar-header {
            background: rgba(255, 255, 255, 0.05);
            padding: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-title {
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }

        .sidebar-content {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
        }

        .keyframe-editor {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .keyframe-editor h4 {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            margin: 0 0 12px 0;
        }

        .editor-field {
            margin-bottom: 12px;
        }

        .editor-field label {
            display: block;
            font-size: 12px;
            color: #a0a0a0;
            margin-bottom: 4px;
            font-weight: 500;
        }

        .editor-field input,
        .editor-field select {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px 10px;
            color: #ffffff;
            font-size: 13px;
        }

        .editor-field input:focus,
        .editor-field select:focus {
            outline: none;
            border-color: #00bcd4;
            box-shadow: 0 0 0 2px rgba(0, 188, 212, 0.2);
        }

        .easing-presets {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 8px;
        }

        .easing-preset {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 11px;
            color: #ffffff;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
        }

        .easing-preset:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .easing-preset.active {
            background: rgba(0, 188, 212, 0.3);
            border-color: #00bcd4;
        }

        /* Easing Curve Preview */
        .curve-preview {
            position: fixed;
            background: rgba(10, 10, 20, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.2s ease;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .curve-preview.show {
            opacity: 1;
            transform: translateY(0);
        }

        .curve-preview-title {
            font-size: 11px;
            color: #a0a0a0;
            margin-bottom: 8px;
            text-align: center;
            font-weight: 500;
        }

        .curve-svg {
            width: 120px;
            height: 80px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .curve-path {
            fill: none;
            stroke: #64ffda;
            stroke-width: 2;
            stroke-linecap: round;
        }

        .curve-grid {
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 0.5;
        }

        .curve-handles {
            fill: #ff9800;
            stroke: #ffffff;
            stroke-width: 1;
        }

        .editor-actions {
            padding: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 8px;
        }

        .btn-editor {
            flex: 1;
            background: linear-gradient(135deg, #4caf50, #45a049);
            border: none;
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .btn-editor:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .btn-editor.secondary {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }

        .btn-editor.secondary:hover {
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.3);
        }

        /* Timeline scrollbar */
        .timeline-ruler::-webkit-scrollbar,
        .timeline-tracks::-webkit-scrollbar {
            height: 8px;
            width: 8px;
        }

        .timeline-ruler::-webkit-scrollbar-track,
        .timeline-tracks::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        .timeline-ruler::-webkit-scrollbar-thumb,
        .timeline-tracks::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        .timeline-ruler::-webkit-scrollbar-thumb:hover,
        .timeline-tracks::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .schema-actions {
            margin-top: 20px;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .btn-copy {
            background: linear-gradient(135deg, #9c27b0, #673ab7);
            box-shadow: 0 2px 8px rgba(156, 39, 176, 0.3);
        }

        .btn-copy:hover {
            box-shadow: 0 4px 16px rgba(156, 39, 176, 0.4);
        }

        .btn-download {
            background: linear-gradient(135deg, #ff9800, #f57c00);
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);
        }

        .btn-download:hover {
            box-shadow: 0 4px 16px rgba(255, 152, 0, 0.4);
        }

        /* JSON Syntax Highlighting */
        .json-key {
            color: #64ffda;
        }

        .json-string {
            color: #c3e88d;
        }

        .json-number {
            color: #f78c6c;
        }

        .json-boolean {
            color: #ff9cac;
        }

        .json-null {
            color: #546e7a;
        }

        /* Responsive schema modal */
        @media (max-width: 768px) {
            .schema-content {
                margin: 20px;
                padding: 20px;
                max-width: calc(100vw - 40px);
                max-height: calc(100vh - 40px);
            }

            .schema-title {
                font-size: 20px;
            }

            .schema-json {
                font-size: 12px;
                padding: 16px;
                max-height: 50vh;
            }

            .schema-actions {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="info">
        <h1>Lamp Robot Animation Viewer</h1>
        <div class="feature">Load Sample: Test with built-in animation</div>
        <div class="feature">Load File: Browse for your own JSON files</div>
        <div class="feature">Drag & Drop: Drop JSON files anywhere</div>
        <div class="feature">Frame Slider: Manual frame-by-frame control</div>
    </div>

    <div class="controls">
        <h4>Animation Controls</h4>
        <div class="control-section">
            <div class="section-label">Playback</div>
            <div class="control-row">
                <button id="playBtn" class="btn">▶ Play</button>
                <button id="pauseBtn" class="btn">⏸ Pause</button>
                <button id="resetBtn" class="btn">⏹ Reset</button>
            </div>
        </div>
        <div class="control-section">
            <div class="section-label">Animation Source</div>
            <div class="control-row">
                <button id="loadSampleBtn" class="btn">📄 Load Sample</button>
                <button id="loadFileBtn" class="btn btn-secondary">📁 Load File</button>
                <input type="file" id="fileInput" accept=".json" style="display: none;">
            </div>
            <div class="control-row">
                <button id="schemaBtn" class="btn btn-secondary">📋 View Schema</button>
                <button id="editorBtn" class="btn btn-secondary">🎬 Animation Editor</button>
            </div>
        </div>
        <div class="control-section">
            <div class="section-label">Frame Control</div>
            <div class="frame-control">
                <div class="frame-control-header">
                    <span class="frame-label">Current Frame</span>
                    <span class="frame-value" id="frameDisplay">0</span>
                </div>
                <input type="range" id="frameSlider" min="0" max="200" value="0" class="frame-slider">
            </div>
        </div>
        <div id="status" class="status">Ready - Load an animation to begin</div>
    </div>

    <div class="property-values">
        <h4>Current Properties</h4>
        <div class="property-grid">
            <div class="property-item">
                <span class="property-label">💡 Brightness</span>
                <span class="property-value" id="brightnessValue">50%</span>
            </div>
            <div class="property-item">
                <span class="property-label">🔄 Rotation</span>
                <span class="property-value" id="rotationValue">180°</span>
            </div>
            <div class="property-item">
                <span class="property-label">↕️ Tilt</span>
                <span class="property-value" id="tiltValue">0°</span>
            </div>
        </div>
    </div>

    <!-- Drag and Drop Overlay -->
    <div id="dropOverlay" class="drop-overlay">
        <div class="drop-zone">
            <div class="drop-icon">📁</div>
            <div class="drop-text">Drop JSON Animation File Here</div>
            <div class="drop-subtext">Supports .json animation files</div>
        </div>
    </div>

        <!-- Schema Modal -->
    <div id="schemaModal" class="schema-modal">
        <div class="schema-content">
            <div class="schema-header">
                <h2 class="schema-title">Animation Schema</h2>
                <button class="schema-close" id="schemaCloseBtn">✕ Close</button>
            </div>
            <div class="schema-body">
                <div class="schema-view-toggle">
                    <button id="toggleViewBtn" class="toggle-view-btn">📋 Switch to Raw JSON</button>
                </div>

                <div id="schemaReadable" class="schema-readable">
                    <!-- Readable format will be populated here -->
                </div>

                <pre class="schema-json" id="schemaJson" style="display: none;"></pre>

                <div class="schema-actions">
                    <button id="copySchemaBtn" class="btn btn-copy">📋 Copy to Clipboard</button>
                    <button id="downloadSchemaBtn" class="btn btn-download">💾 Download File</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Animation Editor Iframe Modal -->
    <div id="editorIframeModal" class="editor-iframe-modal">
        <div class="editor-iframe-content">
            <div class="editor-iframe-header">
                <h2 class="editor-iframe-title">🎬 Animation Editor</h2>
                <button class="editor-iframe-close" id="editorIframeCloseBtn">✕ Close</button>
            </div>
            <div class="editor-iframe-body">
                <iframe id="editorIframe" src="" frameborder="0" width="100%" height="100%"></iframe>
            </div>
        </div>
    </div>



    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, lampRobot;
        let animationData = null;
        let currentFrame = 0;
        let isPlaying = false;
        let animationId = null;
        let startTime = 0;
        let showReadableView = true;



        // DOM elements
        const canvas = document.getElementById('canvas');
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const loadSampleBtn = document.getElementById('loadSampleBtn');
        const loadFileBtn = document.getElementById('loadFileBtn');
        const schemaBtn = document.getElementById('schemaBtn');
        const fileInput = document.getElementById('fileInput');
        const status = document.getElementById('status');
        const frameSlider = document.getElementById('frameSlider');
        const brightnessValue = document.getElementById('brightnessValue');
        const rotationValue = document.getElementById('rotationValue');
        const tiltValue = document.getElementById('tiltValue');
        const dropOverlay = document.getElementById('dropOverlay');
        const dropZone = dropOverlay.querySelector('.drop-zone');
        const schemaModal = document.getElementById('schemaModal');
        const schemaCloseBtn = document.getElementById('schemaCloseBtn');
        const copySchemaBtn = document.getElementById('copySchemaBtn');
        const downloadSchemaBtn = document.getElementById('downloadSchemaBtn');
        const schemaJson = document.getElementById('schemaJson');
        const schemaReadable = document.getElementById('schemaReadable');
        const toggleViewBtn = document.getElementById('toggleViewBtn');

        // Animation Editor elements
        const editorBtn = document.getElementById('editorBtn');

        // Sample animation data
        const sampleAnimation = {
            "frameRate": 60,
            "startFrame": 0,
            "endFrame": 200,
            "loop": true,
            "brightness": {
                "animation": true,
                "keyframe": [
                    {
                        "from_frame": 0,
                        "to_frame": 100,
                        "from_value": 0,
                        "to_value": 100,
                        "bezier": [0.42, 0.0, 0.58, 1.0]
                    },
                    {
                        "from_frame": 101,
                        "to_frame": 200,
                        "from_value": 100,
                        "to_value": 0,
                        "bezier": [0.42, 0.0, 1.0, 1.0]
                    }
                ]
            },
            "rotation": {
                "animation": true,
                "keyframe": [
                    {
                        "from_frame": 0,
                        "to_frame": 70,
                        "from_value": 180,
                        "to_value": 0,
                        "bezier": [0.42, 0.0, 0.58, 1.0]
                    },
                    {
                        "from_frame": 71,
                        "to_frame": 150,
                        "from_value": 0,
                        "to_value": 359,
                        "bezier": [0.42, 0.0, 1.0, 1.0]
                    },
                    {
                        "from_frame": 151,
                        "to_frame": 200,
                        "from_value": 359,
                        "to_value": 180,
                        "bezier": [0.42, 0.0, 1.0, 1.0]
                    }
                ]
            }
        };

        // Animation schema data
        const animationSchema = {
            "$schema": "http://json-schema.org/draft-07/schema#",
            "title": "Robot Animation Configuration Schema",
            "type": "object",
            "required": ["frameRate", "startFrame", "endFrame", "loop"],
            "properties": {
                "frameRate": {
                    "type": "number",
                    "minimum": 1,
                    "maximum": 120,
                    "description": "Animation playback rate in frames per second"
                },
                "startFrame": {
                    "type": "number",
                    "minimum": 0,
                    "description": "Starting frame number of the animation"
                },
                "endFrame": {
                    "type": "number",
                    "minimum": 0,
                    "description": "Ending frame number of the animation"
                },
                "loop": {
                    "type": "boolean",
                    "description": "Whether the animation should loop continuously"
                },
                "brightness": {
                    "$ref": "#/definitions/animationProperty",
                    "description": "Brightness Property animation configuration range [0.0, 100.0]"
                },
                "rotation": {
                    "$ref": "#/definitions/animationProperty",
                    "description": "Motor Rotation Property animation configuration range [0, 359] , 180 degree means robot facing-forward. the value is defined as absolute and mesured counter-clockwise"
                },
                "tilt": {
                    "$ref": "#/definitions/animationProperty",
                    "description": "Motor Tilt Property animation configuration range [-30, 90], -ve value => tilt downward, +ve value => tilt upward. 0 => horizontal plane"
                }
            },
            "definitions": {
                "animationProperty": {
                    "type": "object",
                    "required": ["animation", "keyframe"],
                    "properties": {
                        "animation": {
                            "type": "boolean",
                            "description": "Whether this property should be animated"
                        },
                        "keyframe": {
                            "type": "array",
                            "description": "Array of keyframes defining the animation",
                            "items": {
                                "type": "object",
                                "required": ["from_frame", "to_frame", "from_value", "to_value", "bezier"],
                                "properties": {
                                    "from_frame": {
                                        "type": "number",
                                        "minimum": 0,
                                        "description": "Starting frame of this keyframe segment"
                                    },
                                    "to_frame": {
                                        "type": "number",
                                        "minimum": 0,
                                        "description": "Ending frame of this keyframe segment"
                                    },
                                    "from_value": {
                                        "type": "number",
                                        "description": "Starting value of this keyframe segment"
                                    },
                                    "to_value": {
                                        "type": "number",
                                        "description": "Ending value of this keyframe segment"
                                    },
                                    "bezier": {
                                        "type": "array",
                                        "description": "Bezier curve control points for interpolation, The array contains P1(OutTangent) and P2(Intangent) points of a cubic bezier curve where P1(0.0,0.0), P3(1.0, 1.0) ",
                                        "items": {
                                            "type": "number",
                                            "minimum": 0,
                                            "maximum": 1
                                        },
                                        "minItems": 4,
                                        "maxItems": 4
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };

        // Initialize the scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xF5F5F5);

            // Create camera - positioned for better view of centered lamp
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 4, 8);
            camera.lookAt(0, 2, 0); // Look at the lamp center

            // Create renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = false;

            // Add ambient lighting for the room
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // Add directional light for general room lighting
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            // Create room environment
            createRoom();

            // Create lamp robot (bigger and centered)
            createLampRobot();

            // Add event listeners
            setupEventListeners();

            // Start render loop
            animate();

            status.textContent = 'Ready - Load an animation to begin';
        }

        function createRoom() {
            const roomSize = 20;
            const roomHeight = 8;

            // FLOOR - Wooden texture
            const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xD2B48C }); // Light brown wood
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            scene.add(floor);

            // BACK WALL
            const backWallGeometry = new THREE.PlaneGeometry(roomSize, roomHeight);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xF0F0F0 }); // Light gray
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, roomHeight/2, -roomSize/2);
            scene.add(backWall);

            // LEFT WALL
            const leftWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-roomSize/2, roomHeight/2, 0);
            scene.add(leftWall);

            // RIGHT WALL
            const rightWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(roomSize/2, roomHeight/2, 0);
            scene.add(rightWall);

            // CEILING
            const ceilingGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
            const ceilingMaterial = new THREE.MeshLambertMaterial({ color: 0xFAFAFA }); // Off-white
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = roomHeight;
            scene.add(ceiling);

            // Add some room details - baseboards
            const baseboardGeometry = new THREE.BoxGeometry(roomSize, 0.2, 0.1);
            const baseboardMaterial = new THREE.MeshLambertMaterial({ color: 0xE0E0E0 });

            // Back wall baseboard
            const backBaseboard = new THREE.Mesh(baseboardGeometry, baseboardMaterial);
            backBaseboard.position.set(0, 0.1, -roomSize/2 + 0.05);
            scene.add(backBaseboard);

            // Side baseboards
            const sideBaseboardGeometry = new THREE.BoxGeometry(0.1, 0.2, roomSize);
            const leftBaseboard = new THREE.Mesh(sideBaseboardGeometry, baseboardMaterial);
            leftBaseboard.position.set(-roomSize/2 + 0.05, 0.1, 0);
            scene.add(leftBaseboard);

            const rightBaseboard = new THREE.Mesh(sideBaseboardGeometry, baseboardMaterial);
            rightBaseboard.position.set(roomSize/2 - 0.05, 0.1, 0);
            scene.add(rightBaseboard);
        }

        function createLampRobot() {
            lampRobot = new THREE.Group();

            // Scale factor to make lamp bigger
            const scale = 1.8;

            // 1. BASE - Heavy circular base that sits on the ground (BIGGER)
            const baseGeometry = new THREE.CylinderGeometry(0.4 * scale, 0.5 * scale, 0.15 * scale, 16);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x2c2c2c });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(0, 0.075 * scale, 0); // Centered at origin
            lampRobot.add(base);

            // 2. VERTICAL POST - Goes from base to hinge point (BIGGER)
            const postGeometry = new THREE.CylinderGeometry(0.04 * scale, 0.04 * scale, 1.8 * scale, 12);
            const postMaterial = new THREE.MeshLambertMaterial({ color: 0x404040 });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.set(0, 1.05 * scale, 0);
            lampRobot.add(post);

            // 3. HINGE MECHANISM - The pivot point where rotation happens (BIGGER)
            const hingeBaseGeometry = new THREE.CylinderGeometry(0.08 * scale, 0.08 * scale, 0.12 * scale, 12);
            const hingeMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const hingeBase = new THREE.Mesh(hingeBaseGeometry, hingeMaterial);
            hingeBase.position.set(0, 1.95 * scale, 0);
            lampRobot.add(hingeBase);

            // 4. ROTATION JOINT - This group rotates around Y-axis (horizontal spin)
            const rotationJoint = new THREE.Group();
            rotationJoint.position.set(0, 1.95 * scale, 0); // At the hinge point
            lampRobot.add(rotationJoint);

            // 5. TILT MECHANISM - Connects rotation to tilt, allows X-axis rotation (up/down)
            const tiltJoint = new THREE.Group();
            tiltJoint.position.set(0, 0, 0); // Relative to rotation joint
            rotationJoint.add(tiltJoint);

            // 6. HEAD MOUNTING BRACKET - Connects directly to the hinge (BIGGER)
            const bracketGeometry = new THREE.BoxGeometry(0.08 * scale, 0.06 * scale, 0.06 * scale);
            const bracketMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const bracket = new THREE.Mesh(bracketGeometry, bracketMaterial);
            bracket.position.set(0, 0.1 * scale, 0); // Positioned directly above the hinge
            tiltJoint.add(bracket);

            // 7. LAMP HEAD - Circular disk that houses the light, directly on top (BIGGER)
            const headGeometry = new THREE.CylinderGeometry(0.35 * scale, 0.35 * scale, 0.08 * scale, 20);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xf5f5f5 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 0.1 * scale, 0); // Positioned directly above the hinge
            tiltJoint.add(head);

            // 8. LIGHT BULB - The actual light source (RED) (BIGGER)
            const bulbGeometry = new THREE.SphereGeometry(0.1 * scale, 12, 8);
            const bulbMaterial = new THREE.MeshLambertMaterial({
                color: 0x444444, // Dark when off
                emissive: 0x000000,
                emissiveIntensity: 0
            });
            const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.set(0, 0.08 * scale, 0); // Positioned directly above the hinge
            tiltJoint.add(bulb);

            // 9. ENHANCED LIGHT SOURCE - Focused red spotlight for floor only
            const spotLight = new THREE.SpotLight(0xff0000, 0, 25 * scale, Math.PI / 6, 0.3, 2);
            spotLight.position.set(0, 0.1 * scale, 0); // Positioned directly above the hinge
            spotLight.target.position.set(0, -10, 0); // Point downward from center
            tiltJoint.add(spotLight);
            tiltJoint.add(spotLight.target); // Add target to tilt joint so it moves with lamp

            // 10. LIGHT CONE VISUALIZATION - Shows red light casting downward like real lamp (BIGGER)
            const coneGeometry = new THREE.ConeGeometry(0.8 * scale, 2.5 * scale, 8, 1, true);
            const coneMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000, // Red cone
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            const lightCone = new THREE.Mesh(coneGeometry, coneMaterial);
            lightCone.position.set(0, -1.15 * scale, 0); // Position below the lamp head, centered
            lightCone.rotation.x = 0; // Point cone downward (no rotation needed)
            lightCone.visible = false;
            tiltJoint.add(lightCone);

            // Position the entire lamp at the center of the room
            lampRobot.position.set(0, 0, 0); // Perfect center

            // Store references for animation - only the joints that move
            lampRobot.userData = {
                rotationJoint: rotationJoint,  // Spins horizontally
                tiltJoint: tiltJoint,          // Tilts up/down
                bulb: bulb,                    // For brightness changes
                pointLight: spotLight,        // For light intensity
                lightCone: lightCone,          // For light cone visibility
                head: head,                    // Reference to head
                base: base,                    // Reference to base
                scale: scale                   // Store scale for brightness calculations
            };

            scene.add(lampRobot);
        }

        function setupEventListeners() {
            // Control buttons
            playBtn.addEventListener('click', playAnimation);
            pauseBtn.addEventListener('click', pauseAnimation);
            resetBtn.addEventListener('click', resetAnimation);
            loadSampleBtn.addEventListener('click', loadSampleAnimation);
            loadFileBtn.addEventListener('click', () => fileInput.click());
            schemaBtn.addEventListener('click', showSchema);
            fileInput.addEventListener('change', handleFileInputChange);

            // Schema modal event listeners
            schemaCloseBtn.addEventListener('click', hideSchema);
            copySchemaBtn.addEventListener('click', copySchemaToClipboard);
            downloadSchemaBtn.addEventListener('click', downloadSchemaFile);
            toggleViewBtn.addEventListener('click', toggleSchemaView);
            schemaModal.addEventListener('click', (e) => {
                if (e.target === schemaModal) hideSchema();
            });

            // Animation Editor - iframe overlay
            editorBtn.addEventListener('click', showEditorOverlay);

            // Iframe editor close button
            const editorIframeCloseBtn = document.getElementById('editorIframeCloseBtn');
            editorIframeCloseBtn.addEventListener('click', hideEditorOverlay);

            // Close iframe modal when clicking outside
            const editorIframeModal = document.getElementById('editorIframeModal');
            editorIframeModal.addEventListener('click', (e) => {
                if (e.target === editorIframeModal) hideEditorOverlay();
            });



            // Drag and drop
            document.addEventListener('dragenter', handleDragEnter);
            document.addEventListener('dragover', handleDragOver);
            document.addEventListener('dragleave', handleDragLeave);
            document.addEventListener('drop', handleDrop);

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Frame slider
            frameSlider.addEventListener('input', updateFrame);
            frameSlider.addEventListener('change', updateFrame);

            // Keyboard support
            document.addEventListener('keydown', handleKeyDown);
        }

        function playAnimation() {
            if (!animationData) return;

            isPlaying = true;
            startTime = Date.now() - (currentFrame / animationData.frameRate * 1000);
            status.textContent = '▶ Playing animation...';
            status.className = 'status success';

            if (!animationId) {
                animate();
            }
        }

        function pauseAnimation() {
            isPlaying = false;
            status.textContent = '⏸ Animation paused';
            status.className = 'status';
        }

        function resetAnimation() {
            if (!animationData) return;

            currentFrame = animationData.startFrame;
            frameSlider.value = currentFrame;
            applyFrame(currentFrame);
            status.textContent = '⏹ Animation reset to start';
            status.className = 'status';
        }

        function toggleMainAnimation() {
            if (!animationData) {
                status.textContent = '⚠ No animation loaded';
                status.className = 'status warning';
                return;
            }

            if (isPlaying) {
                pauseAnimation();
            } else {
                playAnimation();
            }
        }

        function loadSampleAnimation() {
            animationData = sampleAnimation;
            currentFrame = animationData.startFrame;

            // Update frame slider range and position
            frameSlider.min = animationData.startFrame;
            frameSlider.max = animationData.endFrame;
            frameSlider.value = currentFrame;

            applyFrame(currentFrame);
            status.textContent = `✅ Sample loaded: ${animationData.endFrame - animationData.startFrame + 1} frames`;
            status.className = 'status success';
        }

                function showSchema() {
            try {
                // Prepare both views
                const formattedSchema = JSON.stringify(animationSchema, null, 2);
                schemaJson.textContent = formattedSchema;
                createReadableSchema();

                // Show the modal
                schemaModal.classList.add('show');
                status.textContent = '📋 Schema displayed';
                status.className = 'status success';
            } catch (error) {
                console.error('Error displaying schema:', error);
                status.textContent = '❌ Error displaying schema';
                status.className = 'status error';
            }
        }

        function createReadableSchema() {
            const schema = animationSchema;

            const readableHTML = `
                <div class="schema-section expanded">
                    <div class="schema-section-header" onclick="toggleSection(this)">
                        <h3 class="schema-section-title">📋 Basic Configuration</h3>
                        <span class="schema-section-toggle">▶</span>
                    </div>
                    <div class="schema-section-content">
                        <div class="schema-section-body">
                            <div class="schema-property">
                                <div class="schema-property-name">frameRate</div>
                                <span class="schema-property-type">number</span>
                                <span class="schema-property-required">required</span>
                                <div class="schema-property-desc">Animation playback rate in frames per second</div>
                                <span class="schema-property-range">Range: 1-120</span>
                            </div>
                            <div class="schema-property">
                                <div class="schema-property-name">startFrame</div>
                                <span class="schema-property-type">number</span>
                                <span class="schema-property-required">required</span>
                                <div class="schema-property-desc">Starting frame number of the animation</div>
                                <span class="schema-property-range">Minimum: 0</span>
                            </div>
                            <div class="schema-property">
                                <div class="schema-property-name">endFrame</div>
                                <span class="schema-property-type">number</span>
                                <span class="schema-property-required">required</span>
                                <div class="schema-property-desc">Ending frame number of the animation</div>
                                <span class="schema-property-range">Minimum: 0</span>
                            </div>
                            <div class="schema-property">
                                <div class="schema-property-name">loop</div>
                                <span class="schema-property-type">boolean</span>
                                <span class="schema-property-required">required</span>
                                <div class="schema-property-desc">Whether the animation should loop continuously</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="schema-section expanded">
                    <div class="schema-section-header" onclick="toggleSection(this)">
                        <h3 class="schema-section-title">💡 Brightness Property</h3>
                        <span class="schema-section-toggle">▶</span>
                    </div>
                    <div class="schema-section-content">
                        <div class="schema-section-body">
                            <div class="schema-property">
                                <div class="schema-property-name">brightness</div>
                                <span class="schema-property-type">animationProperty</span>
                                <div class="schema-property-desc">Brightness Property animation configuration</div>
                                <span class="schema-property-range">Range: 0.0 - 100.0</span>
                                <div class="schema-keyframe-example">{
  "animation": true,
  "keyframe": [
    {
      "from_frame": 0,
      "to_frame": 100,
      "from_value": 0,
      "to_value": 100,
      "bezier": [0.42, 0.0, 0.58, 1.0]
    }
  ]
}</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="schema-section expanded">
                    <div class="schema-section-header" onclick="toggleSection(this)">
                        <h3 class="schema-section-title">🔄 Rotation Property</h3>
                        <span class="schema-section-toggle">▶</span>
                    </div>
                    <div class="schema-section-content">
                        <div class="schema-section-body">
                            <div class="schema-property">
                                <div class="schema-property-name">rotation</div>
                                <span class="schema-property-type">animationProperty</span>
                                <div class="schema-property-desc">Motor Rotation Property animation configuration. 180 degrees means robot facing-forward. Values are absolute and measured counter-clockwise.</div>
                                <span class="schema-property-range">Range: 0 - 359</span>
                                <div class="schema-keyframe-example">{
  "animation": true,
  "keyframe": [
    {
      "from_frame": 0,
      "to_frame": 70,
      "from_value": 180,
      "to_value": 0,
      "bezier": [0.42, 0.0, 0.58, 1.0]
    }
  ]
}</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="schema-section expanded">
                    <div class="schema-section-header" onclick="toggleSection(this)">
                        <h3 class="schema-section-title">↕️ Tilt Property</h3>
                        <span class="schema-section-toggle">▶</span>
                    </div>
                    <div class="schema-section-content">
                        <div class="schema-section-body">
                            <div class="schema-property">
                                <div class="schema-property-name">tilt</div>
                                <span class="schema-property-type">animationProperty</span>
                                <div class="schema-property-desc">Motor Tilt Property animation configuration. Negative values tilt downward, positive values tilt upward. 0 means horizontal plane.</div>
                                <span class="schema-property-range">Range: -30 to 90</span>
                                <div class="schema-keyframe-example">{
  "animation": true,
  "keyframe": [
    {
      "from_frame": 0,
      "to_frame": 50,
      "from_value": 0,
      "to_value": 45,
      "bezier": [0.42, 0.0, 0.58, 1.0]
    }
  ]
}</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="schema-section expanded">
                    <div class="schema-section-header" onclick="toggleSection(this)">
                        <h3 class="schema-section-title">🔧 Keyframe Structure</h3>
                        <span class="schema-section-toggle">▶</span>
                    </div>
                    <div class="schema-section-content">
                        <div class="schema-section-body">
                            <div class="schema-property">
                                <div class="schema-property-name">from_frame</div>
                                <span class="schema-property-type">number</span>
                                <span class="schema-property-required">required</span>
                                <div class="schema-property-desc">Starting frame of this keyframe segment</div>
                                <span class="schema-property-range">Minimum: 0</span>
                            </div>
                            <div class="schema-property">
                                <div class="schema-property-name">to_frame</div>
                                <span class="schema-property-type">number</span>
                                <span class="schema-property-required">required</span>
                                <div class="schema-property-desc">Ending frame of this keyframe segment</div>
                                <span class="schema-property-range">Minimum: 0</span>
                            </div>
                            <div class="schema-property">
                                <div class="schema-property-name">from_value</div>
                                <span class="schema-property-type">number</span>
                                <span class="schema-property-required">required</span>
                                <div class="schema-property-desc">Starting value of this keyframe segment</div>
                            </div>
                            <div class="schema-property">
                                <div class="schema-property-name">to_value</div>
                                <span class="schema-property-type">number</span>
                                <span class="schema-property-required">required</span>
                                <div class="schema-property-desc">Ending value of this keyframe segment</div>
                            </div>
                            <div class="schema-property">
                                <div class="schema-property-name">bezier</div>
                                <span class="schema-property-type">array[4]</span>
                                <span class="schema-property-required">required</span>
                                <div class="schema-property-desc">Bezier curve control points for interpolation. Contains P1(OutTangent) and P2(InTangent) points of a cubic bezier curve where P0(0.0,0.0) and P3(1.0,1.0)</div>
                                <span class="schema-property-range">Values: 0.0 - 1.0</span>
                                <div class="schema-keyframe-example">// Common easing curves:
[0.42, 0.0, 0.58, 1.0]  // ease
[0.42, 0.0, 1.0, 1.0]   // ease-out
[0.0, 0.0, 0.58, 1.0]   // ease-in
[0.25, 0.1, 0.25, 1.0]  // ease-in-out</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            schemaReadable.innerHTML = readableHTML;
        }

        function toggleSchemaView() {
            showReadableView = !showReadableView;

            if (showReadableView) {
                schemaReadable.style.display = 'block';
                schemaJson.style.display = 'none';
                toggleViewBtn.textContent = '📋 Switch to Raw JSON';
            } else {
                schemaReadable.style.display = 'none';
                schemaJson.style.display = 'block';
                toggleViewBtn.textContent = '📖 Switch to Readable View';
            }
        }

        function toggleSection(header) {
            const section = header.parentElement;
            section.classList.toggle('expanded');
        }

        // Make toggleSection available globally
        window.toggleSection = toggleSection;

        // Animation Editor Iframe Functions
        function showEditorOverlay() {
            const editorIframeModal = document.getElementById('editorIframeModal');
            const editorIframe = document.getElementById('editorIframe');

            // Set the iframe source to the animation editor
            editorIframe.src = 'animation-editor.html';

            // Show the modal with animation
            editorIframeModal.classList.add('show');

            // Set up message listener for communication from iframe
            window.addEventListener('message', handleEditorMessage);

            // Send current animation data to editor after it loads
            editorIframe.addEventListener('load', function() {
                // Wait a moment for iframe to be ready
                setTimeout(() => {
                    if (animationData) {
                        // Send current animation data to the editor
                        editorIframe.contentWindow.postMessage({
                            type: 'loadCurrentAnimation',
                            animation: animationData
                        }, '*');
                    }
                }, 50);
            }, { once: true });
        }

        function hideEditorOverlay() {
            const editorIframeModal = document.getElementById('editorIframeModal');
            const editorIframe = document.getElementById('editorIframe');

            // Hide the modal
            editorIframeModal.classList.remove('show');

            // Clear iframe source after animation completes
            setTimeout(() => {
                if (!editorIframeModal.classList.contains('show')) {
                    editorIframe.src = '';
                }
            }, 300);

            // Remove message listener
            window.removeEventListener('message', handleEditorMessage);
        }

        function handleEditorMessage(event) {
            // Handle messages from the iframe editor
            if (event.data && event.data.type === 'loadAnimation') {
                // Load animation data into the main viewer
                if (event.data.animation) {
                    loadAnimationData(event.data.animation);
                    hideEditorOverlay();
                }
            } else if (event.data && event.data.type === 'closeEditor') {
                // Close the iframe editor
                hideEditorOverlay();
            } else if (event.data && event.data.type === 'livePropertyUpdate') {
                // Update 3D model properties in real-time during editor playback
                if (event.data.properties && lampRobot) {
                    updateLampProperties(event.data.properties);
                }
            }
        }

        function updateLampProperties(properties) {
            // Update lamp robot properties in real-time from editor
            if (properties.brightness !== undefined) {
                updateBrightness(properties.brightness);
            }
            if (properties.rotation !== undefined) {
                updateRotation(properties.rotation);
            }
            if (properties.tilt !== undefined) {
                updateTilt(properties.tilt);
            }
        }

        function loadAnimationData(jsonData) {
            try {
                status.textContent = '⏳ Loading animation from editor...';
                status.className = 'status loading';

                animationData = jsonData;
                currentFrame = animationData.startFrame;

                // Update frame slider range and position
                frameSlider.min = animationData.startFrame;
                frameSlider.max = animationData.endFrame;
                frameSlider.value = currentFrame;

                applyFrame(currentFrame);
                status.textContent = `✅ Animation loaded from editor (${animationData.endFrame - animationData.startFrame + 1} frames)`;
                status.className = 'status success';
            } catch (error) {
                console.error('Error loading animation data:', error);
                status.textContent = '❌ Error loading animation from editor';
                status.className = 'status error';
            }
        }



                function updateTimelineConfig() {
            const startFrame = parseInt(editorStartFrame.value);
            const endFrame = parseInt(editorEndFrame.value);
            const totalFrames = endFrame - startFrame + 1;

            // Adaptive pixels per frame based on animation length
            if (totalFrames <= 200) {
                pixelsPerFrame = 5;
            } else if (totalFrames <= 500) {
                pixelsPerFrame = 3;
            } else if (totalFrames <= 1000) {
                pixelsPerFrame = 2;
            } else {
                pixelsPerFrame = 1;
            }

                        timelineWidth = Math.max(totalFrames * pixelsPerFrame, 1000);

            // Update zoom level display
            if (zoomLevel) {
                zoomLevel.textContent = `${pixelsPerFrame}px/frame`;
                if (totalFrames > 200) {
                    zoomLevel.title = `Auto-scaled for ${totalFrames} frames`;
                } else {
                    zoomLevel.title = '';
                }
            }

            renderTimeline();
        }

                function renderTimeline() {
            const startFrame = parseInt(editorStartFrame.value);
            const endFrame = parseInt(editorEndFrame.value);
            const trackLabelWidth = 120; // Width of the track labels

            // Update ruler
            rulerMarks.style.width = (timelineWidth + trackLabelWidth) + 'px';
            rulerMarks.innerHTML = '';

                        // Adaptive frame mark interval based on animation length
            const totalFrames = endFrame - startFrame + 1;
            let markInterval;
            if (totalFrames <= 200) {
                markInterval = 10;
            } else if (totalFrames <= 500) {
                markInterval = 25;
            } else if (totalFrames <= 1000) {
                markInterval = 50;
            } else {
                markInterval = 100;
            }

            for (let frame = startFrame; frame <= endFrame; frame += markInterval) {
                const mark = document.createElement('div');
                mark.className = 'frame-mark';
                mark.style.left = (trackLabelWidth + (frame - startFrame) * pixelsPerFrame) + 'px';

                const number = document.createElement('span');
                number.className = 'frame-number';
                number.textContent = frame;
                mark.appendChild(number);

                rulerMarks.appendChild(mark);
            }

            // Update track widths
            [brightnessTrack, rotationTrack, tiltTrack].forEach(track => {
                track.style.width = timelineWidth + 'px';
            });

            renderKeyframes();
        }

        function renderKeyframes() {
            // Clear existing keyframes
            document.querySelectorAll('.keyframe').forEach(kf => kf.remove());

            const startFrame = parseInt(editorStartFrame.value);

            // Render keyframes for each property
            Object.keys(editorKeyframes).forEach(property => {
                const track = document.getElementById(property + 'Track');
                editorKeyframes[property].forEach((keyframe, index) => {
                    const keyframeEl = document.createElement('div');
                    keyframeEl.className = 'keyframe';
                    keyframeEl.style.left = ((keyframe.frame - startFrame) * pixelsPerFrame) + 'px';
                    keyframeEl.dataset.property = property;
                    keyframeEl.dataset.index = index;

                    keyframeEl.addEventListener('click', (e) => {
                        e.stopPropagation();
                        selectKeyframe(property, index);
                    });

                    track.appendChild(keyframeEl);
                });
            });
        }

                function handleTrackClick(event, property) {
            if (event.target.classList.contains('keyframe')) return;

            const rect = event.target.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const startFrame = parseInt(editorStartFrame.value);
            const frame = Math.round(startFrame + (x / pixelsPerFrame));

            addKeyframeAtFrame(property, frame);
        }

        function handleRulerClick(event) {
            if (event.target.classList.contains('playhead-handle')) return;

            const rect = timelineRuler.getBoundingClientRect();
            const x = event.clientX - rect.left - 120; // Account for track label width
            const startFrame = parseInt(editorStartFrame.value);
            const endFrame = parseInt(editorEndFrame.value);
            const frame = Math.max(startFrame, Math.min(endFrame, Math.round(startFrame + (x / pixelsPerFrame))));

            editorCurrentFrame = frame;
            updatePlayhead();
        }

        function addKeyframeAtFrame(property, frame) {
            const defaultValues = {
                brightness: 50,
                rotation: 180,
                tilt: 0
            };

            const keyframe = {
                frame: frame,
                value: defaultValues[property],
                easing: [0.42, 0.0, 0.58, 1.0] // ease
            };

            // Insert keyframe in correct position
            const keyframes = editorKeyframes[property];
            let insertIndex = keyframes.findIndex(kf => kf.frame > frame);
            if (insertIndex === -1) insertIndex = keyframes.length;

            keyframes.splice(insertIndex, 0, keyframe);

            renderKeyframes();
            selectKeyframe(property, insertIndex);
            updateCurrentFrameValues();
        }

        function addKeyframe() {
            if (!selectedKeyframe) {
                // Add keyframe at current frame for brightness by default
                addKeyframeAtFrame('brightness', editorCurrentFrame);
            } else {
                // Add keyframe for selected property
                addKeyframeAtFrame(selectedKeyframe.property, editorCurrentFrame);
            }
        }

        function deleteSelectedKeyframe() {
            if (!selectedKeyframe) return;

            const keyframes = editorKeyframes[selectedKeyframe.property];
            keyframes.splice(selectedKeyframe.index, 1);

            selectedKeyframe = null;
            renderKeyframes();
            updateSidebar();
            updateCurrentFrameValues();
        }

        function selectKeyframe(property, index) {
            // Clear previous selection
            document.querySelectorAll('.keyframe.selected').forEach(kf => {
                kf.classList.remove('selected');
            });

            // Select new keyframe
            const keyframeEl = document.querySelector(`[data-property="${property}"][data-index="${index}"]`);
            if (keyframeEl) {
                keyframeEl.classList.add('selected');
                selectedKeyframe = { property, index };
                updateSidebar();
            }
        }

                function updateSidebar() {
            if (!selectedKeyframe) {
                keyframeEditorSection.style.display = 'none';
                noKeyframeSelected.style.display = 'block';
                return;
            }

            noKeyframeSelected.style.display = 'none';
            keyframeEditorSection.style.display = 'block';

            const keyframe = editorKeyframes[selectedKeyframe.property][selectedKeyframe.index];
            const propertyInfo = {
                brightness: { name: 'Brightness', min: 0, max: 100, unit: '%' },
                rotation: { name: 'Rotation', min: 0, max: 359, unit: '°' },
                tilt: { name: 'Tilt', min: -30, max: 90, unit: '°' }
            };

            const info = propertyInfo[selectedKeyframe.property];

            keyframeEditorSection.innerHTML = `
                <div class="keyframe-editor">
                    <h4>${info.name} Keyframe</h4>
                    <div class="editor-field">
                        <label>Frame</label>
                        <input type="number" id="keyframeFrame" value="${keyframe.frame}" min="0">
                    </div>
                    <div class="editor-field">
                        <label>Value (${info.unit})</label>
                        <input type="number" id="keyframeValue" value="${keyframe.value}" min="${info.min}" max="${info.max}" step="0.1">
                    </div>
                    <div class="editor-field">
                        <label>Easing</label>
                        <div class="easing-presets">
                            <div class="easing-preset" data-easing="0.42,0.0,0.58,1.0">Ease</div>
                            <div class="easing-preset" data-easing="0.42,0.0,1.0,1.0">Ease Out</div>
                            <div class="easing-preset" data-easing="0.0,0.0,0.58,1.0">Ease In</div>
                            <div class="easing-preset" data-easing="0.25,0.1,0.25,1.0">Ease In-Out</div>
                        </div>
                        <input type="text" id="keyframeEasing" value="${keyframe.easing.join(',')}" placeholder="p1x,p1y,p2x,p2y">
                    </div>
                </div>
            `;

                        // Add event listeners
            document.getElementById('keyframeFrame').addEventListener('change', updateKeyframeProperty);
            document.getElementById('keyframeValue').addEventListener('change', updateKeyframeProperty);
            document.getElementById('keyframeEasing').addEventListener('change', updateKeyframeProperty);

            // Easing preset listeners - need to use setTimeout to ensure DOM is ready
            setTimeout(() => {
                const presets = keyframeEditorSection.querySelectorAll('.easing-preset');
                console.log('Found easing presets:', presets.length); // Debug log

                presets.forEach(preset => {
                    preset.addEventListener('click', () => {
                        document.getElementById('keyframeEasing').value = preset.dataset.easing;
                        updateKeyframeProperty();
                    });

                    // Add curve preview on hover
                    preset.addEventListener('mouseenter', (e) => {
                        console.log('Hover detected on:', preset.textContent); // Debug log
                        const easingValues = preset.dataset.easing.split(',').map(v => parseFloat(v));
                        const presetName = preset.textContent;
                        showCurvePreview(e, easingValues, presetName);
                    });

                    preset.addEventListener('mouseleave', hideCurvePreview);
                });
            }, 10);


            // Highlight current easing
            const currentEasing = keyframe.easing.join(',');
            document.querySelectorAll('.easing-preset').forEach(preset => {
                if (preset.dataset.easing === currentEasing) {
                    preset.classList.add('active');
                }
            });

            // Add curve preview to custom input
            addCustomEasingPreview();
        }

        function updateKeyframeProperty() {
            if (!selectedKeyframe) return;

            const keyframe = editorKeyframes[selectedKeyframe.property][selectedKeyframe.index];
            const frameInput = document.getElementById('keyframeFrame');
            const valueInput = document.getElementById('keyframeValue');
            const easingInput = document.getElementById('keyframeEasing');

            if (frameInput) keyframe.frame = parseInt(frameInput.value);
            if (valueInput) keyframe.value = parseFloat(valueInput.value);
            if (easingInput) {
                const easingValues = easingInput.value.split(',').map(v => parseFloat(v.trim()));
                if (easingValues.length === 4 && easingValues.every(v => !isNaN(v))) {
                    keyframe.easing = easingValues;
                }
            }

            // Re-sort keyframes by frame
            editorKeyframes[selectedKeyframe.property].sort((a, b) => a.frame - b.frame);

            renderKeyframes();

            // Find and reselect the keyframe after sorting
            const newIndex = editorKeyframes[selectedKeyframe.property].findIndex(kf => kf === keyframe);
            selectKeyframe(selectedKeyframe.property, newIndex);
            updateCurrentFrameValues();
        }

                        // Curve Preview Functions
        function showCurvePreview(event, bezierValues, title) {
            console.log('showCurvePreview called:', title, bezierValues); // Debug log

            if (bezierValues.length !== 4) {
                console.log('Invalid bezier values length:', bezierValues.length);
                return;
            }

            curveTitle.textContent = title;
            updateCurveDisplay(bezierValues);

                                    // Smart positioning - left side preferred, with fallbacks
            const rect = event.target.getBoundingClientRect();
            const previewWidth = 144; // Approximate width of preview (120px + padding)
            const previewHeight = 120; // Approximate height
            const gap = 10;

            let left, top;

            // Try left side first
            if (rect.left - previewWidth - gap >= 0) {
                left = rect.left - previewWidth - gap;
            }
            // If not enough space on left, try right side
            else if (rect.right + previewWidth + gap <= window.innerWidth) {
                left = rect.right + gap;
            }
            // If neither side works, center it and position above/below
            else {
                left = Math.max(gap, Math.min(window.innerWidth - previewWidth - gap, rect.left - previewWidth/2));
            }

            // Vertical positioning
            if (rect.top - previewHeight - gap >= 0) {
                top = rect.top - previewHeight - gap; // Above
            } else {
                top = rect.bottom + gap; // Below
            }

            // Ensure it doesn't go off-screen
            top = Math.max(gap, Math.min(window.innerHeight - previewHeight - gap, top));

            console.log('Smart positioning preview at:', left, top); // Debug log

            curvePreview.style.display = 'block';
            curvePreview.style.left = left + 'px';
            curvePreview.style.top = top + 'px';
            curvePreview.style.position = 'fixed';

            // Force a reflow then add show class
            curvePreview.offsetHeight;
            curvePreview.classList.add('show');
            console.log('Preview should be visible now'); // Debug log
        }

        function hideCurvePreview() {
            console.log('Hiding curve preview'); // Debug log
            curvePreview.classList.remove('show');

            // Hide after transition completes
            setTimeout(() => {
                if (!curvePreview.classList.contains('show')) {
                    curvePreview.style.display = 'none';
                }
            }, 200);
        }

        function updateCurveDisplay(bezierValues) {
            const [p1x, p1y, p2x, p2y] = bezierValues;

            // Convert bezier values (0-1) to SVG coordinates
            // SVG: 10,70 (bottom-left) to 90,10 (top-right)
            const x1 = 10 + (p1x * 80);
            const y1 = 70 - (p1y * 60);
            const x2 = 10 + (p2x * 80);
            const y2 = 70 - (p2y * 60);

            // Update control point positions
            handle1.setAttribute('cx', x1);
            handle1.setAttribute('cy', y1);
            handle2.setAttribute('cx', x2);
            handle2.setAttribute('cy', y2);

            // Generate cubic bezier curve path
            const pathData = `M 10,70 C ${x1},${y1} ${x2},${y2} 90,10`;
            curvePath.setAttribute('d', pathData);
        }

        // Add hover preview to custom easing input
        function addCustomEasingPreview() {
            const easingInput = document.getElementById('keyframeEasing');
            if (!easingInput) return;

            let previewTimeout;

            easingInput.addEventListener('mouseenter', (e) => {
                clearTimeout(previewTimeout);
                previewTimeout = setTimeout(() => {
                    const value = easingInput.value;
                    const easingValues = value.split(',').map(v => parseFloat(v.trim()));
                    if (easingValues.length === 4 && easingValues.every(v => !isNaN(v))) {
                        showCurvePreview(e, easingValues, 'Custom');
                    }
                }, 500); // Delay to avoid showing on quick mouse pass
            });

            easingInput.addEventListener('mouseleave', () => {
                clearTimeout(previewTimeout);
                hideCurvePreview();
            });
        }

        function loadDefaultKeyframes() {
            // Load some default keyframes to get started
            editorKeyframes = {
                brightness: [
                    { frame: 0, value: 0, easing: [0.42, 0.0, 0.58, 1.0] },
                    { frame: 100, value: 100, easing: [0.42, 0.0, 1.0, 1.0] },
                    { frame: 200, value: 0, easing: [0.42, 0.0, 1.0, 1.0] }
                ],
                rotation: [
                    { frame: 0, value: 180, easing: [0.42, 0.0, 0.58, 1.0] },
                    { frame: 70, value: 0, easing: [0.42, 0.0, 1.0, 1.0] },
                    { frame: 150, value: 359, easing: [0.42, 0.0, 1.0, 1.0] },
                    { frame: 200, value: 180, easing: [0.42, 0.0, 1.0, 1.0] }
                ],
                tilt: []
            };
            renderKeyframes();
            updateCurrentFrameValues();
        }

        function playEditorAnimation() {
            editorIsPlaying = true;
            editorStartTime = Date.now() - (editorCurrentFrame / parseInt(editorFrameRate.value) * 1000);

            if (!editorAnimationId) {
                animateEditor();
            }
        }

        function pauseEditorAnimation() {
            editorIsPlaying = false;
            if (editorAnimationId) {
                cancelAnimationFrame(editorAnimationId);
                editorAnimationId = null;
            }
        }

        function resetEditorAnimation() {
            pauseEditorAnimation();
            editorCurrentFrame = parseInt(editorStartFrame.value);
            updatePlayhead();
        }

        function animateEditor() {
            if (editorIsPlaying) {
                const elapsed = Date.now() - editorStartTime;
                const frameRate = parseInt(editorFrameRate.value);
                const startFrame = parseInt(editorStartFrame.value);
                const endFrame = parseInt(editorEndFrame.value);

                editorCurrentFrame = startFrame + Math.floor(elapsed / (1000 / frameRate));

                if (editorCurrentFrame > endFrame) {
                    if (editorLoop.checked) {
                        editorCurrentFrame = startFrame;
                        editorStartTime = Date.now();
                    } else {
                        editorCurrentFrame = endFrame;
                        pauseEditorAnimation();
                    }
                }

                updatePlayhead();
                editorAnimationId = requestAnimationFrame(animateEditor);
            }
        }

        function updatePlayhead() {
            const startFrame = parseInt(editorStartFrame.value);
            const trackLabelWidth = 120; // Width of track labels
            const left = trackLabelWidth + (editorCurrentFrame - startFrame) * pixelsPerFrame;
            playhead.style.left = left + 'px';

            // Update frame display
            playheadFrameDisplay.textContent = `Frame ${editorCurrentFrame}`;

            // Update current property values
            updateCurrentFrameValues();
        }

                function updateCurrentFrameValues() {
            const brightness = interpolatePropertyValue('brightness', editorCurrentFrame);
            const rotation = interpolatePropertyValue('rotation', editorCurrentFrame);
            const tilt = interpolatePropertyValue('tilt', editorCurrentFrame);

            trackBrightness.textContent = `${Math.round(brightness)}%`;
            trackRotation.textContent = `${Math.round(rotation)}°`;
            trackTilt.textContent = `${Math.round(tilt)}°`;
        }

        function interpolatePropertyValue(property, frame) {
            const segments = editorKeyframes[property];

            if (!segments || segments.length === 0) {
                // Return default values if no segments
                const defaults = { brightness: 50, rotation: 180, tilt: 0 };
                return defaults[property];
            }

            // Check if we're dealing with the new segment format or old keyframe format
            const isSegmentFormat = segments[0] && segments[0].hasOwnProperty('startFrame');

            if (isSegmentFormat) {
                // New segment-based format - sort segments by start frame
                const sortedSegments = segments.slice().sort((a, b) => a.startFrame - b.startFrame);

                // Find the segment that contains this frame
                for (let i = 0; i < sortedSegments.length; i++) {
                    const segment = sortedSegments[i];

                    // Check if frame is within this segment
                    if (frame >= segment.startFrame && frame <= segment.endFrame) {
                        // If frame exactly matches start frame
                        if (frame === segment.startFrame) {
                            return segment.startValue;
                        }

                        // If frame exactly matches end frame
                        if (frame === segment.endFrame) {
                            return segment.endValue;
                        }

                        // Interpolate within the segment
                        const totalFrames = segment.endFrame - segment.startFrame;
                        const currentProgress = frame - segment.startFrame;
                        let t = currentProgress / totalFrames;

                        // Apply easing curve
                        if (segment.easing && segment.easing.length === 4) {
                            t = cubicBezier(t, segment.easing[0], segment.easing[1],
                                               segment.easing[2], segment.easing[3]);
                        }

                        // Linear interpolation with easing
                        return segment.startValue + (segment.endValue - segment.startValue) * t;
                    }
                }

                // If frame is before all segments, return the start value of the first segment
                if (frame < sortedSegments[0].startFrame) {
                    return sortedSegments[0].startValue;
                }

                // If frame is after all segments, return the end value of the last segment
                if (frame > sortedSegments[sortedSegments.length - 1].endFrame) {
                    return sortedSegments[sortedSegments.length - 1].endValue;
                }

                // Handle gaps between segments - hold the last value
                // Find the last segment that ended before or at this frame
                let lastCompletedSegment = null;
                for (let i = 0; i < sortedSegments.length; i++) {
                    const segment = sortedSegments[i];
                    if (segment.endFrame < frame) {
                        lastCompletedSegment = segment;
                    } else {
                        break; // We've reached a segment that starts after our frame
                    }
                }

                if (lastCompletedSegment) {
                    // Hold the end value of the last completed segment
                    return lastCompletedSegment.endValue;
                }

                // Fallback - if no previous segment found, return start value of next segment
                for (let i = 0; i < sortedSegments.length; i++) {
                    const segment = sortedSegments[i];
                    if (segment.startFrame > frame) {
                        return segment.startValue;
                    }
                }

                // Final fallback to default values
                const defaults = { brightness: 50, rotation: 180, tilt: 0 };
                return defaults[property];

            } else {
                // Old keyframe format - maintain backward compatibility
                const keyframes = segments; // segments is actually keyframes in old format

                // Find the keyframes that surround this frame
                let beforeKeyframe = null;
                let afterKeyframe = null;

                for (let i = 0; i < keyframes.length; i++) {
                    if (keyframes[i].frame <= frame) {
                        beforeKeyframe = keyframes[i];
                    }
                    if (keyframes[i].frame >= frame && afterKeyframe === null) {
                        afterKeyframe = keyframes[i];
                    }
                }

                // If frame is before all keyframes, hold the first keyframe value
                if (beforeKeyframe === null) {
                    return keyframes[0].value;
                }

                // If frame is after all keyframes, hold the last keyframe value
                if (afterKeyframe === null) {
                    return beforeKeyframe.value;
                }

                // If frame exactly matches a keyframe
                if (beforeKeyframe.frame === frame) {
                    return beforeKeyframe.value;
                }

                // Interpolate between keyframes
                const totalFrames = afterKeyframe.frame - beforeKeyframe.frame;
                const currentProgress = frame - beforeKeyframe.frame;
                let t = currentProgress / totalFrames;

                // Apply easing curve
                if (beforeKeyframe.easing && beforeKeyframe.easing.length === 4) {
                    t = cubicBezier(t, beforeKeyframe.easing[0], beforeKeyframe.easing[1],
                                       beforeKeyframe.easing[2], beforeKeyframe.easing[3]);
                }

                // Linear interpolation with easing
                return beforeKeyframe.value + (afterKeyframe.value - beforeKeyframe.value) * t;
            }
        }

        function startDragPlayhead(event) {
            event.preventDefault();
            isDraggingPlayhead = true;
            dragStartX = event.clientX;
            dragStartFrame = editorCurrentFrame;

            // Pause animation while dragging
            const wasPlaying = editorIsPlaying;
            pauseEditorAnimation();
            playheadHandle.dataset.wasPlaying = wasPlaying;
        }

        function dragPlayhead(event) {
            if (!isDraggingPlayhead) return;

            event.preventDefault();
            const deltaX = event.clientX - dragStartX;
            const deltaFrames = Math.round(deltaX / pixelsPerFrame);
            const newFrame = Math.max(
                parseInt(editorStartFrame.value),
                Math.min(
                    parseInt(editorEndFrame.value),
                    dragStartFrame + deltaFrames
                )
            );

            editorCurrentFrame = newFrame;
            updatePlayhead();
        }

        function stopDragPlayhead(event) {
            if (!isDraggingPlayhead) return;

            isDraggingPlayhead = false;

            // Resume animation if it was playing before drag
            if (playheadHandle.dataset.wasPlaying === 'true') {
                playEditorAnimation();
            }
        }

        function exportAnimationJson() {
            const animationConfig = {
                frameRate: parseInt(editorFrameRate.value),
                startFrame: parseInt(editorStartFrame.value),
                endFrame: parseInt(editorEndFrame.value),
                loop: editorLoop.checked
            };

            // Convert editor keyframes to JSON format
            Object.keys(editorKeyframes).forEach(property => {
                if (editorKeyframes[property].length > 0) {
                    const keyframes = editorKeyframes[property];
                    const jsonKeyframes = [];

                    for (let i = 0; i < keyframes.length - 1; i++) {
                        const current = keyframes[i];
                        const next = keyframes[i + 1];

                        jsonKeyframes.push({
                            from_frame: current.frame,
                            to_frame: next.frame,
                            from_value: current.value,
                            to_value: next.value,
                            bezier: current.easing
                        });
                    }

                    animationConfig[property] = {
                        animation: true,
                        keyframe: jsonKeyframes
                    };
                }
            });

            const jsonString = JSON.stringify(animationConfig, null, 2);

            // Download the JSON file
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = 'custom_animation.json';
            downloadLink.style.display = 'none';

            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);

            URL.revokeObjectURL(url);

            status.textContent = '✅ Animation JSON exported';
            status.className = 'status success';
        }

        function loadEditorAnimationToViewer() {
            const animationConfig = {
                frameRate: parseInt(editorFrameRate.value),
                startFrame: parseInt(editorStartFrame.value),
                endFrame: parseInt(editorEndFrame.value),
                loop: editorLoop.checked
            };

            // Convert editor keyframes to JSON format
            Object.keys(editorKeyframes).forEach(property => {
                if (editorKeyframes[property].length > 0) {
                    const keyframes = editorKeyframes[property];
                    const jsonKeyframes = [];

                    for (let i = 0; i < keyframes.length - 1; i++) {
                        const current = keyframes[i];
                        const next = keyframes[i + 1];

                        jsonKeyframes.push({
                            from_frame: current.frame,
                            to_frame: next.frame,
                            from_value: current.value,
                            to_value: next.value,
                            bezier: current.easing
                        });
                    }

                    animationConfig[property] = {
                        animation: true,
                        keyframe: jsonKeyframes
                    };
                }
            });

            // Load into main viewer
            animationData = animationConfig;
            currentFrame = animationData.startFrame;

            // Update frame slider range and position
            frameSlider.min = animationData.startFrame;
            frameSlider.max = animationData.endFrame;
            frameSlider.value = currentFrame;

            applyFrame(currentFrame);

            // Close editor and show success
            hideEditor();
            status.textContent = '✅ Animation loaded to viewer';
            status.className = 'status success';
        }

        function hideSchema() {
            schemaModal.classList.remove('show');
        }

        function copySchemaToClipboard() {
            try {
                const schemaText = JSON.stringify(animationSchema, null, 2);
                navigator.clipboard.writeText(schemaText).then(() => {
                    status.textContent = '✅ Schema copied to clipboard';
                    status.className = 'status success';
                }).catch(() => {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = schemaText;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    status.textContent = '✅ Schema copied to clipboard';
                    status.className = 'status success';
                });
            } catch (error) {
                console.error('Error copying schema:', error);
                status.textContent = '❌ Error copying schema';
                status.className = 'status error';
            }
        }

        async function downloadSchemaFile() {
            try {
                const schemaJson = JSON.stringify(animationSchema, null, 2);

                // Try to use File System Access API for modern browsers
                if ('showSaveFilePicker' in window) {
                    try {
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: 'robot_animation_schema.json',
                            types: [
                                {
                                    description: 'JSON files',
                                    accept: {
                                        'application/json': ['.json'],
                                    },
                                },
                            ],
                        });

                        const writable = await fileHandle.createWritable();
                        await writable.write(schemaJson);
                        await writable.close();

                        status.textContent = '✅ Schema saved successfully';
                        status.className = 'status success';
                        return;
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            // User cancelled the save dialog
                            return;
                        }
                        console.error('Error saving schema file:', error);
                        // Fall through to download method if save picker failed
                    }
                }

                // Fallback: Download the JSON file (for older browsers or if save picker failed)
                const blob = new Blob([schemaJson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = 'robot_animation_schema.json';
                downloadLink.style.display = 'none';

                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);

                URL.revokeObjectURL(url);

                status.textContent = '✅ Schema downloaded successfully';
                status.className = 'status success';
            } catch (error) {
                console.error('Error downloading schema:', error);
                status.textContent = '❌ Error downloading schema';
                status.className = 'status error';
            }
        }

        async function loadAnimationFromFile(file) {
            try {
                status.textContent = '⏳ Loading animation file...';
                status.className = 'status loading';

                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const jsonData = JSON.parse(event.target.result);
                        animationData = jsonData;
                        currentFrame = animationData.startFrame;

                        // Update frame slider range and position
                        frameSlider.min = animationData.startFrame;
                        frameSlider.max = animationData.endFrame;
                        frameSlider.value = currentFrame;

                        applyFrame(currentFrame);
                        status.textContent = `✅ Loaded: ${file.name} (${animationData.endFrame - animationData.startFrame + 1} frames)`;
                        status.className = 'status success';
                    } catch (parseError) {
                        status.textContent = '❌ Invalid JSON file format';
                        status.className = 'status error';
                    }
                };
                reader.readAsText(file);
            } catch (error) {
                console.error('Error loading animation from file:', error);
                status.textContent = '❌ Error loading animation file';
                status.className = 'status error';
            }
        }

        function handleDrop(event) {
            event.preventDefault();
            hideDropOverlay();

            const file = event.dataTransfer.files[0];
            if (file && file.name.endsWith('.json')) {
                loadAnimationFromFile(file);
            } else {
                status.textContent = '❌ Please drop a valid JSON file';
                status.className = 'status error';
            }
        }

        function handleFileInputChange(event) {
            const file = event.target.files[0];
            if (file && file.name.endsWith('.json')) {
                loadAnimationFromFile(file);
            } else {
                status.textContent = '❌ Please select a valid JSON file';
                status.className = 'status error';
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
            if (!dropOverlay.classList.contains('show')) {
                showDropOverlay();
            }
            dropZone.classList.add('drag-over');
        }

        function handleDragEnter(event) {
            event.preventDefault();
            showDropOverlay();
        }

        function handleDragLeave(event) {
            event.preventDefault();
            // Only hide if we're leaving the window entirely
            if (event.clientX === 0 || event.clientY === 0 ||
                event.clientX === window.innerWidth || event.clientY === window.innerHeight) {
                hideDropOverlay();
            }
            dropZone.classList.remove('drag-over');
        }

        function showDropOverlay() {
            dropOverlay.classList.add('show');
        }

        function hideDropOverlay() {
            dropOverlay.classList.remove('show');
            dropZone.classList.remove('drag-over');
        }

        function handleKeyDown(event) {
            // Don't interfere when user is typing in input fields
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                return;
            }

            if (event.key === 'Escape') {
                if (dropOverlay.classList.contains('show')) {
                    hideDropOverlay();
                } else if (schemaModal.classList.contains('show')) {
                    hideSchema();
                }
            } else if (event.key === ' ') { // Spacebar
                event.preventDefault(); // Prevent page scroll
                toggleMainAnimation();
            }
        }

        function handleEditorKeydown(event) {
            // Only handle shortcuts when editor is open
            if (!editorModal.classList.contains('show')) return;

            // Don't interfere when user is typing in input fields
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;

            switch (event.key) {
                case ' ': // Spacebar
                    event.preventDefault(); // Prevent page scroll
                    toggleEditorPlayback();
                    break;
                case 'Home':
                    event.preventDefault();
                    jumpToStart();
                    break;
                case 'End':
                    event.preventDefault();
                    jumpToEnd();
                    break;
                case 'ArrowLeft':
                    if (event.shiftKey) {
                        event.preventDefault();
                        jumpToPreviousKeyframe();
                    } else {
                        event.preventDefault();
                        stepFrame(-1);
                    }
                    break;
                case 'ArrowRight':
                    if (event.shiftKey) {
                        event.preventDefault();
                        jumpToNextKeyframe();
                    } else {
                        event.preventDefault();
                        stepFrame(1);
                    }
                    break;
            }
        }

        function toggleEditorPlayback() {
            if (editorIsPlaying) {
                pauseEditorAnimation();
            } else {
                playEditorAnimation();
            }
        }

        function jumpToStart() {
            pauseEditorAnimation();
            editorCurrentFrame = parseInt(editorStartFrame.value);
            updatePlayhead();
        }

        function jumpToEnd() {
            pauseEditorAnimation();
            editorCurrentFrame = parseInt(editorEndFrame.value);
            updatePlayhead();
        }

        function stepFrame(direction) {
            pauseEditorAnimation();
            const startFrame = parseInt(editorStartFrame.value);
            const endFrame = parseInt(editorEndFrame.value);
            editorCurrentFrame = Math.max(startFrame, Math.min(endFrame, editorCurrentFrame + direction));
            updatePlayhead();
        }

        function jumpToPreviousKeyframe() {
            pauseEditorAnimation();

            // Collect all keyframes and sort by frame
            const allKeyframes = [];
            Object.keys(editorKeyframes).forEach(property => {
                editorKeyframes[property].forEach(kf => {
                    allKeyframes.push(kf.frame);
                });
            });

            const uniqueFrames = [...new Set(allKeyframes)].sort((a, b) => a - b);
            const currentIndex = uniqueFrames.findIndex(frame => frame >= editorCurrentFrame);

            if (currentIndex > 0) {
                editorCurrentFrame = uniqueFrames[currentIndex - 1];
            } else if (uniqueFrames.length > 0) {
                editorCurrentFrame = uniqueFrames[uniqueFrames.length - 1]; // Wrap to last
            }

            updatePlayhead();
        }

        function jumpToNextKeyframe() {
            pauseEditorAnimation();

            // Collect all keyframes and sort by frame
            const allKeyframes = [];
            Object.keys(editorKeyframes).forEach(property => {
                editorKeyframes[property].forEach(kf => {
                    allKeyframes.push(kf.frame);
                });
            });

            const uniqueFrames = [...new Set(allKeyframes)].sort((a, b) => a - b);
            const nextFrame = uniqueFrames.find(frame => frame > editorCurrentFrame);

            if (nextFrame !== undefined) {
                editorCurrentFrame = nextFrame;
            } else if (uniqueFrames.length > 0) {
                editorCurrentFrame = uniqueFrames[0]; // Wrap to first
            }

            updatePlayhead();
        }

        function updateRotation(value) {
            if (!lampRobot || !lampRobot.userData.rotationJoint) return;

            const rotationJoint = lampRobot.userData.rotationJoint;

            // Normalize rotation to 0-359 range
            let normalizedValue = value % 360;
            if (normalizedValue < 0) normalizedValue += 360;

            const angle = (normalizedValue - 180) * Math.PI / 180;

            // Update display value
            if (rotationValue) {
                rotationValue.textContent = `${Math.round(normalizedValue)}°`;
            }

            // Rotate the entire head assembly horizontally
            rotationJoint.rotation.y = angle;
        }

        function updateTilt(value) {
            if (!lampRobot || !lampRobot.userData.tiltJoint) return;

            const tiltJoint = lampRobot.userData.tiltJoint;

            // Clamp tilt value to safe range to prevent extreme positions
            const clampedValue = Math.max(-30, Math.min(90, value));
            const angle = -clampedValue * Math.PI / 180; // Negative to make positive values tilt up

            // Update display value
            if (tiltValue) {
                tiltValue.textContent = `${Math.round(clampedValue)}°`;
            }

            // Tilt the arm and head up/down from horizontal
            // Negative angle = tilt down, Positive angle = tilt up
            tiltJoint.rotation.x = angle;
        }

        function updateBrightness(value) {
            if (!lampRobot || !lampRobot.userData.bulb) return;

            const bulb = lampRobot.userData.bulb;
            const pointLight = lampRobot.userData.pointLight;
            const lightCone = lampRobot.userData.lightCone;
            const scale = lampRobot.userData.scale;

            // Clamp brightness to 0-100 range
            const clampedValue = Math.max(0, Math.min(100, value));
            const intensity = clampedValue / 100;

            // Update display value
            if (brightnessValue) {
                brightnessValue.textContent = `${Math.round(clampedValue)}%`;
            }

            if (intensity === 0) {
                // Bulb is completely off
                bulb.material.emissive.setHex(0x000000);
                bulb.material.emissiveIntensity = 0;
                bulb.material.color.setHex(0x444444); // Dark bulb when off
                pointLight.intensity = 0;
                if (lightCone) {
                    lightCone.visible = false;
                }
            } else {
                // Bulb is on - red light with varying intensity
                const redColor = new THREE.Color(0xff0000); // Pure red

                // Update bulb appearance - gets redder as intensity increases
                bulb.material.color.setHex(0x444444 + (0xbb0000 * intensity)); // Dark to red
                bulb.material.emissive.copy(redColor);
                bulb.material.emissiveIntensity = intensity;

                // Update point light - red with intensity control
                pointLight.color.copy(redColor);
                pointLight.intensity = intensity * 4 * scale; // Strong red light for floor casting

                // Update light cone - red cone with opacity based on intensity
                if (lightCone) {
                    lightCone.material.color.copy(redColor);
                    lightCone.material.opacity = intensity * 0.25; // More visible red cone
                    lightCone.visible = true;
                }
            }
        }

        function applyFrame(frame) {
            if (!animationData) return;

            // Store current values
            let brightness = 50;
            let rotation = 180;
            let tilt = 0;

            // Apply brightness animation
            if (animationData.brightness && animationData.brightness.animation) {
                brightness = interpolateProperty(animationData.brightness, frame);
                updateBrightness(brightness);
            }

            // Apply rotation animation
            if (animationData.rotation && animationData.rotation.animation) {
                rotation = interpolateProperty(animationData.rotation, frame);
                updateRotation(rotation);
            }

            // Apply tilt animation
            if (animationData.tilt && animationData.tilt.animation) {
                tilt = interpolateProperty(animationData.tilt, frame);
                updateTilt(tilt);
            }

                            // Update frame slider and display
                frameSlider.value = frame;
                document.getElementById('frameDisplay').textContent = frame;
                currentFrame = frame;

                // Update property value displays
                brightnessValue.textContent = `${Math.round(brightness)}%`;
                rotationValue.textContent = `${Math.round(rotation)}°`;
                tiltValue.textContent = `${Math.round(tilt)}°`;
        }

        function interpolateProperty(property, frame) {
            if (!property.keyframe || property.keyframe.length === 0) {
                return 0;
            }

            // Sort keyframes by start frame to ensure proper order
            const sortedKeyframes = property.keyframe.slice().sort((a, b) => a.from_frame - b.from_frame);

            // Check if frame is within any segment
            for (let i = 0; i < sortedKeyframes.length; i++) {
                const keyframe = sortedKeyframes[i];
                if (frame >= keyframe.from_frame && frame <= keyframe.to_frame) {
                    const segmentLength = keyframe.to_frame - keyframe.from_frame;
                    const frameProgress = frame - keyframe.from_frame;
                    let t = frameProgress / segmentLength;

                    if (keyframe.bezier && keyframe.bezier.length === 4) {
                        t = cubicBezier(t, keyframe.bezier[0], keyframe.bezier[1], keyframe.bezier[2], keyframe.bezier[3]);
                    }

                    return keyframe.from_value + (keyframe.to_value - keyframe.from_value) * t;
                }
            }

            // If frame is before all segments, return the start value of the first segment
            if (frame < sortedKeyframes[0].from_frame) {
                return sortedKeyframes[0].from_value;
            }

            // If frame is after all segments, return the end value of the last segment
            if (frame > sortedKeyframes[sortedKeyframes.length - 1].to_frame) {
                return sortedKeyframes[sortedKeyframes.length - 1].to_value;
            }

            // Handle gaps between segments - hold the last value
            // Find the last segment that ended before or at this frame
            let lastCompletedKeyframe = null;
            for (let i = 0; i < sortedKeyframes.length; i++) {
                const keyframe = sortedKeyframes[i];
                if (keyframe.to_frame < frame) {
                    lastCompletedKeyframe = keyframe;
                } else {
                    break; // We've reached a segment that starts after our frame
                }
            }

            if (lastCompletedKeyframe) {
                // Hold the end value of the last completed segment
                return lastCompletedKeyframe.to_value;
            }

            // Fallback - if no previous segment found, return start value of next segment
            for (let i = 0; i < sortedKeyframes.length; i++) {
                const keyframe = sortedKeyframes[i];
                if (keyframe.from_frame > frame) {
                    return keyframe.from_value;
                }
            }

            // Final fallback - return the end value of the last segment
            return sortedKeyframes[sortedKeyframes.length - 1].to_value;
        }

        function cubicBezier(t, p1x, p1y, p2x, p2y) {
            const cx = 3 * p1x;
            const bx = 3 * (p2x - p1x) - cx;
            const ax = 1 - cx - bx;
            const cy = 3 * p1y;
            const by = 3 * (p2y - p1y) - cy;
            const ay = 1 - cy - by;

            const sampleCurveY = (t) => ((ay * t + by) * t + cy) * t;
            return sampleCurveY(t);
        }

        function animate() {
            animationId = requestAnimationFrame(animate);

            if (isPlaying && animationData) {
                const elapsed = Date.now() - startTime;
                const frameTime = 1000 / animationData.frameRate;
                currentFrame = Math.floor(elapsed / frameTime);

                if (currentFrame > animationData.endFrame) {
                    if (animationData.loop) {
                        currentFrame = animationData.startFrame;
                        startTime = Date.now();
                    } else {
                        currentFrame = animationData.endFrame;
                        pauseAnimation();
                    }
                }

                applyFrame(currentFrame);
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateFrame() {
            if (!animationData) return;
            const frame = parseInt(frameSlider.value);
            if (frame >= animationData.startFrame && frame <= animationData.endFrame) {
                applyFrame(frame);
            } else {
                frameSlider.value = currentFrame; // Snap to nearest valid frame
            }
        }

        // Initialize the application
        init();
    </script>
</body>
</html>