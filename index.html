<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lamp Robot Animation</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            overflow: hidden;
            height: 100vh;
            color: #e0e0e0;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .info {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(20, 20, 35, 0.95);
            backdrop-filter: blur(20px);
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow:
                0 4px 20px rgba(0, 0, 0, 0.4),
                0 1px 4px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            max-width: 280px;
        }

        .info h1 {
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 6px;
            letter-spacing: -0.01em;
        }

        .info p {
            font-size: 14px;
            color: #b0b0b0;
            line-height: 1.5;
            margin: 0;
        }

        .info .feature {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 12px;
            color: #c0c0c0;
        }

        .info .feature::before {
            content: '•';
            color: #64ffda;
            font-weight: bold;
            margin-right: 8px;
        }

        .controls {
            position: absolute;
            bottom: 16px;
            right: 16px;
            background: rgba(20, 20, 35, 0.95);
            backdrop-filter: blur(20px);
            padding: 20px;
            border-radius: 16px;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.5),
                0 2px 8px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            width: 380px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .controls:hover {
            transform: translateY(-2px);
            box-shadow:
                0 12px 40px rgba(0, 0, 0, 0.15),
                0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .controls h4 {
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 20px;
            letter-spacing: -0.01em;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section:last-child {
            margin-bottom: 0;
        }

        .section-label {
            font-size: 12px;
            font-weight: 500;
            color: #a0a0a0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .control-row {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }

        .btn {
            flex: 1;
            background: linear-gradient(135deg, #00bcd4, #009688);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 188, 212, 0.3);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
            transition: left 0.5s;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(0, 188, 212, 0.4);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:active {
            transform: translateY(0);
            transition: transform 0.1s;
        }

        .btn:disabled {
            background: #3a3a3a;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #37474f, #455a64);
            box-shadow: 0 2px 8px rgba(55, 71, 79, 0.3);
        }

        .btn-secondary:hover {
            box-shadow: 0 4px 16px rgba(55, 71, 79, 0.4);
        }

        .frame-control {
            background: rgba(255, 255, 255, 0.05);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .frame-control-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 12px;
        }

        .frame-label {
            font-size: 12px;
            font-weight: 500;
            color: #a0a0a0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .frame-value {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            background: rgba(0, 188, 212, 0.2);
            padding: 4px 12px;
            border-radius: 20px;
            border: 1px solid rgba(0, 188, 212, 0.3);
            min-width: 50px;
            text-align: center;
        }

        .frame-slider {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            position: relative;
        }

        .frame-slider::-webkit-slider-track {
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
        }

        .frame-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00bcd4, #009688);
            cursor: pointer;
            box-shadow:
                0 2px 8px rgba(0, 188, 212, 0.3),
                0 0 0 0px rgba(0, 188, 212, 0.2);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .frame-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow:
                0 4px 12px rgba(0, 188, 212, 0.4),
                0 0 0 8px rgba(0, 188, 212, 0.1);
        }

        .frame-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00bcd4, #009688);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 188, 212, 0.3);
        }

        .status {
            background: rgba(255, 255, 255, 0.05);
            color: #b0b0b0;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 16px;
            text-align: center;
        }

        .status.success {
            background: rgba(0, 150, 136, 0.2);
            color: #64ffda;
            border-color: rgba(100, 255, 218, 0.3);
        }

        .status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #ff8a80;
            border-color: rgba(255, 138, 128, 0.3);
        }

        /* Loading animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .loading {
            animation: pulse 2s infinite;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .info {
                top: 12px;
                left: 12px;
                right: 12px;
                max-width: none;
                padding: 12px 16px;
            }

            .controls {
                bottom: 12px;
                left: 12px;
                right: 12px;
                width: auto;
                padding: 16px;
            }

            .control-row {
                flex-direction: column;
            }
        }

        /* Prevent overlap on medium screens */
        @media (max-width: 1200px) {
            .controls {
                width: 320px;
            }

            .info {
                max-width: 250px;
            }
        }

        /* Focus states for accessibility */
        .btn:focus,
        .frame-slider:focus {
            outline: 2px solid #00bcd4;
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="info">
        <h1>Lamp Robot Animation Viewer</h1>
        <div class="feature">Load Sample: Test with built-in animation</div>
        <div class="feature">Load File: Browse for your own JSON files</div>
        <div class="feature">Frame Slider: Manual frame-by-frame control</div>
    </div>

    <div class="controls">
        <h4>Animation Controls</h4>
        <div class="control-section">
            <div class="section-label">Playback</div>
            <div class="control-row">
                <button id="playBtn" class="btn">▶ Play</button>
                <button id="pauseBtn" class="btn">⏸ Pause</button>
                <button id="resetBtn" class="btn">⏹ Reset</button>
            </div>
        </div>
        <div class="control-section">
            <div class="section-label">Animation Source</div>
            <div class="control-row">
                <button id="loadSampleBtn" class="btn">📄 Load Sample</button>
                <button id="loadFileBtn" class="btn btn-secondary">�� Load File</button>
                <input type="file" id="fileInput" accept=".json" style="display: none;">
            </div>
        </div>
        <div class="control-section">
            <div class="section-label">Frame Control</div>
            <div class="frame-control">
                <div class="frame-control-header">
                    <span class="frame-label">Current Frame</span>
                    <span class="frame-value" id="frameDisplay">0</span>
                </div>
                <input type="range" id="frameSlider" min="0" max="200" value="0" class="frame-slider">
            </div>
        </div>
        <div id="status" class="status">Ready - Load an animation to begin</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, lampRobot;
        let animationData = null;
        let currentFrame = 0;
        let isPlaying = false;
        let animationId = null;
        let startTime = 0;

        // DOM elements
        const canvas = document.getElementById('canvas');
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const loadSampleBtn = document.getElementById('loadSampleBtn');
        const loadFileBtn = document.getElementById('loadFileBtn');
        const fileInput = document.getElementById('fileInput');
        const status = document.getElementById('status');
        const frameSlider = document.getElementById('frameSlider');

        // Sample animation data
        const sampleAnimation = {
            "frameRate": 60,
            "startFrame": 0,
            "endFrame": 200,
            "loop": true,
            "brightness": {
                "animation": true,
                "keyframe": [
                    {
                        "from_frame": 0,
                        "to_frame": 100,
                        "from_value": 0,
                        "to_value": 100,
                        "bezier": [0.42, 0.0, 0.58, 1.0]
                    },
                    {
                        "from_frame": 101,
                        "to_frame": 200,
                        "from_value": 100,
                        "to_value": 0,
                        "bezier": [0.42, 0.0, 1.0, 1.0]
                    }
                ]
            },
            "rotation": {
                "animation": true,
                "keyframe": [
                    {
                        "from_frame": 0,
                        "to_frame": 70,
                        "from_value": 180,
                        "to_value": 0,
                        "bezier": [0.42, 0.0, 0.58, 1.0]
                    },
                    {
                        "from_frame": 71,
                        "to_frame": 150,
                        "from_value": 0,
                        "to_value": 359,
                        "bezier": [0.42, 0.0, 1.0, 1.0]
                    },
                    {
                        "from_frame": 151,
                        "to_frame": 200,
                        "from_value": 359,
                        "to_value": 180,
                        "bezier": [0.42, 0.0, 1.0, 1.0]
                    }
                ]
            }
        };

        // Initialize the scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xF5F5F5);

            // Create camera - positioned for better view of centered lamp
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 4, 8);
            camera.lookAt(0, 2, 0); // Look at the lamp center

            // Create renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = false;

            // Add ambient lighting for the room
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // Add directional light for general room lighting
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            // Create room environment
            createRoom();

            // Create lamp robot (bigger and centered)
            createLampRobot();

            // Add event listeners
            setupEventListeners();

            // Start render loop
            animate();

            status.textContent = 'Ready - Load an animation to begin';
        }

        function createRoom() {
            const roomSize = 20;
            const roomHeight = 8;

            // FLOOR - Wooden texture
            const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xD2B48C }); // Light brown wood
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            scene.add(floor);

            // BACK WALL
            const backWallGeometry = new THREE.PlaneGeometry(roomSize, roomHeight);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xF0F0F0 }); // Light gray
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, roomHeight/2, -roomSize/2);
            scene.add(backWall);

            // LEFT WALL
            const leftWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-roomSize/2, roomHeight/2, 0);
            scene.add(leftWall);

            // RIGHT WALL
            const rightWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(roomSize/2, roomHeight/2, 0);
            scene.add(rightWall);

            // CEILING
            const ceilingGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
            const ceilingMaterial = new THREE.MeshLambertMaterial({ color: 0xFAFAFA }); // Off-white
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = roomHeight;
            scene.add(ceiling);

            // Add some room details - baseboards
            const baseboardGeometry = new THREE.BoxGeometry(roomSize, 0.2, 0.1);
            const baseboardMaterial = new THREE.MeshLambertMaterial({ color: 0xE0E0E0 });

            // Back wall baseboard
            const backBaseboard = new THREE.Mesh(baseboardGeometry, baseboardMaterial);
            backBaseboard.position.set(0, 0.1, -roomSize/2 + 0.05);
            scene.add(backBaseboard);

            // Side baseboards
            const sideBaseboardGeometry = new THREE.BoxGeometry(0.1, 0.2, roomSize);
            const leftBaseboard = new THREE.Mesh(sideBaseboardGeometry, baseboardMaterial);
            leftBaseboard.position.set(-roomSize/2 + 0.05, 0.1, 0);
            scene.add(leftBaseboard);

            const rightBaseboard = new THREE.Mesh(sideBaseboardGeometry, baseboardMaterial);
            rightBaseboard.position.set(roomSize/2 - 0.05, 0.1, 0);
            scene.add(rightBaseboard);
        }

        function createLampRobot() {
            lampRobot = new THREE.Group();

            // Scale factor to make lamp bigger
            const scale = 1.8;

            // 1. BASE - Heavy circular base that sits on the ground (BIGGER)
            const baseGeometry = new THREE.CylinderGeometry(0.4 * scale, 0.5 * scale, 0.15 * scale, 16);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x2c2c2c });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(0, 0.075 * scale, 0); // Centered at origin
            lampRobot.add(base);

            // 2. VERTICAL POST - Goes from base to hinge point (BIGGER)
            const postGeometry = new THREE.CylinderGeometry(0.04 * scale, 0.04 * scale, 1.8 * scale, 12);
            const postMaterial = new THREE.MeshLambertMaterial({ color: 0x404040 });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.set(0, 1.05 * scale, 0);
            lampRobot.add(post);

            // 3. HINGE MECHANISM - The pivot point where rotation happens (BIGGER)
            const hingeBaseGeometry = new THREE.CylinderGeometry(0.08 * scale, 0.08 * scale, 0.12 * scale, 12);
            const hingeMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const hingeBase = new THREE.Mesh(hingeBaseGeometry, hingeMaterial);
            hingeBase.position.set(0, 1.95 * scale, 0);
            lampRobot.add(hingeBase);

            // 4. ROTATION JOINT - This group rotates around Y-axis (horizontal spin)
            const rotationJoint = new THREE.Group();
            rotationJoint.position.set(0, 1.95 * scale, 0); // At the hinge point
            lampRobot.add(rotationJoint);

            // 5. TILT MECHANISM - Connects rotation to tilt, allows X-axis rotation (up/down)
            const tiltJoint = new THREE.Group();
            tiltJoint.position.set(0, 0, 0); // Relative to rotation joint
            rotationJoint.add(tiltJoint);

            // 6. ARM ASSEMBLY - The horizontal arm that extends from the hinge (BIGGER)
            const armGeometry = new THREE.CylinderGeometry(0.025 * scale, 0.025 * scale, 1.2 * scale, 8);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0x505050 });
            const arm = new THREE.Mesh(armGeometry, armMaterial);
            arm.position.set(0, 0, 0.6 * scale); // Extends forward from the hinge
            arm.rotation.x = Math.PI / 2; // Rotate to make it horizontal
            tiltJoint.add(arm);

            // 7. HEAD MOUNTING BRACKET - Connects arm to head (BIGGER)
            const bracketGeometry = new THREE.BoxGeometry(0.08 * scale, 0.06 * scale, 0.06 * scale);
            const bracketMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const bracket = new THREE.Mesh(bracketGeometry, bracketMaterial);
            bracket.position.set(0, 0, 1.2 * scale);
            tiltJoint.add(bracket);

            // 8. LAMP HEAD - Circular disk that houses the light (BIGGER)
            const headGeometry = new THREE.CylinderGeometry(0.35 * scale, 0.35 * scale, 0.08 * scale, 20);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xf5f5f5 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 0, 1.2 * scale);
            tiltJoint.add(head);

            // 9. LIGHT BULB - The actual light source (RED) (BIGGER)
            const bulbGeometry = new THREE.SphereGeometry(0.1 * scale, 12, 8);
            const bulbMaterial = new THREE.MeshLambertMaterial({
                color: 0x444444, // Dark when off
                emissive: 0x000000,
                emissiveIntensity: 0
            });
            const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.set(0, -0.02 * scale, 1.2 * scale);
            tiltJoint.add(bulb);

            // 10. ENHANCED LIGHT SOURCE - Focused red spotlight for floor only
            const spotLight = new THREE.SpotLight(0xff0000, 0, 25 * scale, Math.PI / 6, 0.3, 2);
            spotLight.position.set(0, 0, 1.2 * scale);
            spotLight.target.position.set(0, -10, 1.2 * scale); // Point downward
            tiltJoint.add(spotLight);
            tiltJoint.add(spotLight.target); // Add target to tilt joint so it moves with lamp

            // 11. LIGHT CONE VISUALIZATION - Shows red light casting downward like real lamp (BIGGER)
            const coneGeometry = new THREE.ConeGeometry(0.8 * scale, 2.5 * scale, 8, 1, true);
            const coneMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000, // Red cone
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            const lightCone = new THREE.Mesh(coneGeometry, coneMaterial);
            lightCone.position.set(0, -1.25 * scale, 1.2 * scale); // Position below the lamp head
            lightCone.rotation.x = 0; // Point cone downward (no rotation needed)
            lightCone.visible = false;
            tiltJoint.add(lightCone);

            // Position the entire lamp at the center of the room
            lampRobot.position.set(0, 0, 0); // Perfect center

            // Store references for animation - only the joints that move
            lampRobot.userData = {
                rotationJoint: rotationJoint,  // Spins horizontally
                tiltJoint: tiltJoint,          // Tilts up/down
                bulb: bulb,                    // For brightness changes
                pointLight: spotLight,        // For light intensity
                lightCone: lightCone,          // For light cone visibility
                head: head,                    // Reference to head
                arm: arm,                      // Reference to arm
                base: base,                    // Reference to base
                scale: scale                   // Store scale for brightness calculations
            };

            scene.add(lampRobot);
        }

        function setupEventListeners() {
            // Control buttons
            playBtn.addEventListener('click', playAnimation);
            pauseBtn.addEventListener('click', pauseAnimation);
            resetBtn.addEventListener('click', resetAnimation);
            loadSampleBtn.addEventListener('click', loadSampleAnimation);
            loadFileBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileInputChange);

            // Drag and drop
            document.addEventListener('dragover', handleDragOver);
            document.addEventListener('dragleave', handleDragLeave);
            document.addEventListener('drop', handleDrop);

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Frame slider
            frameSlider.addEventListener('input', updateFrame);
            frameSlider.addEventListener('change', updateFrame);
        }

        function playAnimation() {
            if (!animationData) return;

            isPlaying = true;
            startTime = Date.now() - (currentFrame / animationData.frameRate * 1000);
            status.textContent = '▶ Playing animation...';
            status.className = 'status success';

            if (!animationId) {
                animate();
            }
        }

        function pauseAnimation() {
            isPlaying = false;
            status.textContent = '⏸ Animation paused';
            status.className = 'status';
        }

        function resetAnimation() {
            if (!animationData) return;

            currentFrame = animationData.startFrame;
            frameSlider.value = currentFrame;
            applyFrame(currentFrame);
            status.textContent = '⏹ Animation reset to start';
            status.className = 'status';
        }

        function loadSampleAnimation() {
            animationData = sampleAnimation;
            currentFrame = animationData.startFrame;

            // Update frame slider range and position
            frameSlider.min = animationData.startFrame;
            frameSlider.max = animationData.endFrame;
            frameSlider.value = currentFrame;

            applyFrame(currentFrame);
            status.textContent = `✅ Sample loaded: ${animationData.endFrame - animationData.startFrame + 1} frames`;
            status.className = 'status success';
        }

        async function loadAnimationFromFile(file) {
            try {
                status.textContent = '⏳ Loading animation file...';
                status.className = 'status loading';

                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const jsonData = JSON.parse(event.target.result);
                        animationData = jsonData;
                        currentFrame = animationData.startFrame;

                        // Update frame slider range and position
                        frameSlider.min = animationData.startFrame;
                        frameSlider.max = animationData.endFrame;
                        frameSlider.value = currentFrame;

                        applyFrame(currentFrame);
                        status.textContent = `✅ Loaded: ${file.name} (${animationData.endFrame - animationData.startFrame + 1} frames)`;
                        status.className = 'status success';
                    } catch (parseError) {
                        status.textContent = '❌ Invalid JSON file format';
                        status.className = 'status error';
                    }
                };
                reader.readAsText(file);
            } catch (error) {
                console.error('Error loading animation from file:', error);
                status.textContent = '❌ Error loading animation file';
                status.className = 'status error';
            }
        }

        function handleDrop(event) {
            event.preventDefault();
            const file = event.dataTransfer.files[0];
            if (file && file.name.endsWith('.json')) {
                loadAnimationFromFile(file);
            } else {
                status.textContent = '❌ Please drop a valid JSON file';
                status.className = 'status error';
            }
        }

        function handleFileInputChange(event) {
            const file = event.target.files[0];
            if (file && file.name.endsWith('.json')) {
                loadAnimationFromFile(file);
            } else {
                status.textContent = '❌ Please select a valid JSON file';
                status.className = 'status error';
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
        }

        function handleDragLeave(event) {
            event.preventDefault();
        }

        function updateRotation(value) {
            if (!lampRobot || !lampRobot.userData.rotationJoint) return;

            const rotationJoint = lampRobot.userData.rotationJoint;
            const angle = (value - 180) * Math.PI / 180;

            // Rotate the entire head assembly horizontally
            rotationJoint.rotation.y = angle;
        }

        function updateTilt(value) {
            if (!lampRobot || !lampRobot.userData.tiltJoint) return;

            const tiltJoint = lampRobot.userData.tiltJoint;
            const angle = -value * Math.PI / 180; // Negative to make positive values tilt up

            // Tilt the arm and head up/down from horizontal
            // Negative angle = tilt down, Positive angle = tilt up
            tiltJoint.rotation.x = angle;
        }

        function updateBrightness(value) {
            if (!lampRobot || !lampRobot.userData.bulb) return;

            const bulb = lampRobot.userData.bulb;
            const pointLight = lampRobot.userData.pointLight;
            const lightCone = lampRobot.userData.lightCone;
            const scale = lampRobot.userData.scale;

            const intensity = value / 100;

            if (intensity === 0) {
                // Bulb is completely off
                bulb.material.emissive.setHex(0x000000);
                bulb.material.emissiveIntensity = 0;
                bulb.material.color.setHex(0x444444); // Dark bulb when off
                pointLight.intensity = 0;
                if (lightCone) {
                    lightCone.visible = false;
                }
            } else {
                // Bulb is on - red light with varying intensity
                const redColor = new THREE.Color(0xff0000); // Pure red

                // Update bulb appearance - gets redder as intensity increases
                bulb.material.color.setHex(0x444444 + (0xbb0000 * intensity)); // Dark to red
                bulb.material.emissive.copy(redColor);
                bulb.material.emissiveIntensity = intensity;

                // Update point light - red with intensity control
                pointLight.color.copy(redColor);
                pointLight.intensity = intensity * 4 * scale; // Strong red light for floor casting

                // Update light cone - red cone with opacity based on intensity
                if (lightCone) {
                    lightCone.material.color.copy(redColor);
                    lightCone.material.opacity = intensity * 0.25; // More visible red cone
                    lightCone.visible = true;
                }
            }
        }

        function applyFrame(frame) {
            if (!animationData) return;

            // Store current values
            let brightness = 50;
            let rotation = 180;
            let tilt = 0;

            // Apply brightness animation
            if (animationData.brightness && animationData.brightness.animation) {
                brightness = interpolateProperty(animationData.brightness, frame);
                updateBrightness(brightness);
            }

            // Apply rotation animation
            if (animationData.rotation && animationData.rotation.animation) {
                rotation = interpolateProperty(animationData.rotation, frame);
                updateRotation(rotation);
            }

            // Apply tilt animation
            if (animationData.tilt && animationData.tilt.animation) {
                tilt = interpolateProperty(animationData.tilt, frame);
                updateTilt(tilt);
            }

            // Update frame slider and display
            frameSlider.value = frame;
            document.getElementById('frameDisplay').textContent = frame;
            currentFrame = frame;
        }

        function interpolateProperty(property, frame) {
            if (!property.keyframe || property.keyframe.length === 0) {
                return 0;
            }

            for (let i = 0; i < property.keyframe.length; i++) {
                const keyframe = property.keyframe[i];
                if (frame >= keyframe.from_frame && frame <= keyframe.to_frame) {
                    const segmentLength = keyframe.to_frame - keyframe.from_frame;
                    const frameProgress = frame - keyframe.from_frame;
                    let t = frameProgress / segmentLength;

                    if (keyframe.bezier && keyframe.bezier.length === 4) {
                        t = cubicBezier(t, keyframe.bezier[0], keyframe.bezier[1], keyframe.bezier[2], keyframe.bezier[3]);
                    }

                    return keyframe.from_value + (keyframe.to_value - keyframe.from_value) * t;
                }
            }

            const lastKeyframe = property.keyframe[property.keyframe.length - 1];
            return lastKeyframe.to_value;
        }

        function cubicBezier(t, p1x, p1y, p2x, p2y) {
            const cx = 3 * p1x;
            const bx = 3 * (p2x - p1x) - cx;
            const ax = 1 - cx - bx;
            const cy = 3 * p1y;
            const by = 3 * (p2y - p1y) - cy;
            const ay = 1 - cy - by;

            const sampleCurveY = (t) => ((ay * t + by) * t + cy) * t;
            return sampleCurveY(t);
        }

        function animate() {
            animationId = requestAnimationFrame(animate);

            if (isPlaying && animationData) {
                const elapsed = Date.now() - startTime;
                const frameTime = 1000 / animationData.frameRate;
                currentFrame = Math.floor(elapsed / frameTime);

                if (currentFrame > animationData.endFrame) {
                    if (animationData.loop) {
                        currentFrame = animationData.startFrame;
                        startTime = Date.now();
                    } else {
                        currentFrame = animationData.endFrame;
                        pauseAnimation();
                    }
                }

                applyFrame(currentFrame);
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateFrame() {
            if (!animationData) return;
            const frame = parseInt(frameSlider.value);
            if (frame >= animationData.startFrame && frame <= animationData.endFrame) {
                applyFrame(frame);
            } else {
                frameSlider.value = currentFrame; // Snap to nearest valid frame
            }
        }

        // Initialize the application
        init();
    </script>
</body>
</html>