<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robot Animation Editor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            overflow: hidden;
            height: 100vh;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            outline: none; /* Hide focus outline when auto-focused for keyboard shortcuts */
        }

        /* Iframe mode - full space utilization */
        .iframe-mode {
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }

        /* Animation Editor */
        .editor-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 1;
            visibility: visible;
        }

        /* Iframe mode - no modal wrapper needed */
        .iframe-mode .editor-modal {
            position: static;
            width: 100%;
            height: 100vh;
            background: transparent;
            backdrop-filter: none;
            align-items: stretch;
            justify-content: stretch;
            padding: 0;
            margin: 0;
        }

        .iframe-mode .editor-content {
            width: 100%;
            height: 100vh;
            max-width: none;
            max-height: none;
            margin: 0;
            border-radius: 0;
            border: none;
            transform: none;
            box-shadow: none;
        }

        .iframe-mode .editor-body {
            flex: 1;
            height: 100vh; /* Full viewport height since no main header */
            min-height: 0;
        }

        .iframe-mode .editor-timeline {
            height: 100%;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .iframe-mode .timeline-header {
            flex-shrink: 0; /* Don't shrink the header */
        }

        .iframe-mode .timeline-ruler {
            flex-shrink: 0; /* Don't shrink the ruler */
        }

        .iframe-mode .timeline-tracks {
            flex: 1; /* Take all remaining space */
            min-height: 0;
            overflow: auto;
        }

        .iframe-mode .editor-sidebar {
            height: 100vh;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .iframe-mode .sidebar-content {
            flex: 1;
            overflow-y: auto;
        }

        .iframe-mode .editor-header {
            display: none; /* Hide duplicate header in iframe */
        }



        /* Ensure curve preview stays within iframe bounds */
        .iframe-mode .curve-preview {
            position: absolute;
            z-index: 1000;
        }

        .editor-content {
            background: rgba(15, 15, 25, 0.95);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            width: 95vw;
            height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transform: scale(1);
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6);
        }

        .editor-header {
            background: rgba(255, 255, 255, 0.05);
            padding: 16px 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-title {
            font-size: 20px;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }

        .editor-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .editor-close {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
            border-radius: 8px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .editor-close:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .editor-body {
            flex: 1;
            display: flex;
            overflow: hidden;
            min-height: 0;
        }

        .editor-timeline {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(10, 10, 20, 0.8);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 0;
            overflow: hidden;
        }

        .timeline-header {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .timeline-config {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .config-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .config-label {
            font-size: 12px;
            color: #a0a0a0;
            font-weight: 500;
        }

        .config-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 4px 8px;
            color: #ffffff;
            font-size: 12px;
            width: 60px;
        }

        .timeline-ruler {
            background: rgba(0, 0, 0, 0.3);
            height: 30px;
            position: relative;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            overflow-x: auto;
            width: 100%;
        }

        .ruler-marks {
            height: 100%;
            position: relative;
            min-width: 100%;
        }

        .frame-mark {
            position: absolute;
            top: 0;
            bottom: 0;
            border-left: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: flex-end;
            padding-bottom: 4px;
        }

        .frame-number {
            font-size: 10px;
            color: #888;
            margin-left: 2px;
        }

        .timeline-tracks {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
            position: relative;
        }

        .property-track {
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            min-height: 60px;
            display: flex;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .property-track:hover {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .property-track.hover-highlight {
            background-color: rgba(0, 188, 212, 0.08);
            border-left: 3px solid #00bcd4;
        }

        .track-label {
            width: 120px;
            background: rgba(255, 255, 255, 0.03);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 500;
            color: #ffffff;
        }

        .track-name {
            font-size: 13px;
            font-weight: 500;
            color: #ffffff;
            margin-bottom: 2px;
        }

        .track-value {
            font-size: 11px;
            font-weight: 600;
            color: #64ffda;
            background: rgba(100, 255, 218, 0.15);
            padding: 2px 6px;
            border-radius: 8px;
            text-align: center;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            width: fit-content;
        }

        .track-timeline {
            flex: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.2);
            cursor: crosshair;
        }

                        .keyframe {
            position: absolute;
            height: 6px;
            background: linear-gradient(90deg, #00bcd4, #009688);
            border: 1px solid rgba(255, 255, 255, 0.4);
            cursor: grab;
            top: 50%;
            transform: translateY(-50%);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
            border-radius: 3px;
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .keyframe::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                rgba(255, 255, 255, 0.15) 0%,
                rgba(255, 255, 255, 0.08) 50%,
                rgba(255, 255, 255, 0.15) 100%);
            border-radius: 3px;
            pointer-events: none;
            opacity: 0.7;
        }

        .keyframe:hover {
            height: 8px;
            background: linear-gradient(90deg, #26c6da, #00acc1);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 4px 12px rgba(0, 188, 212, 0.6);
            transform: translateY(-50%) scale(1.05);
        }

        .keyframe:hover::before {
            background: linear-gradient(90deg,
                rgba(255, 255, 255, 0.25) 0%,
                rgba(255, 255, 255, 0.15) 50%,
                rgba(255, 255, 255, 0.25) 100%);
            opacity: 1;
        }

        .keyframe.selected {
            background: linear-gradient(90deg, #ff9800, #f57c00);
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 4px 16px rgba(255, 152, 0, 0.8);
            height: 8px;
            transform: translateY(-50%) scale(1.02);
        }

        .keyframe.selected::before {
            background: linear-gradient(90deg,
                rgba(255, 255, 255, 0.3) 0%,
                rgba(255, 255, 255, 0.2) 50%,
                rgba(255, 255, 255, 0.3) 100%);
            opacity: 1;
        }

        .keyframe:active {
            cursor: grabbing;
        }

        .keyframe-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ffffff;
            border: 2px solid #00bcd4;
            border-radius: 50%;
            cursor: grab;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 11;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .keyframe-handle:hover {
            transform: translate(-50%, -50%) scale(1.4);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.8);
            background: #f0f0f0;
        }

        .keyframe.selected .keyframe-handle {
            border-color: #ff9800;
            background: #fff3e0;
            box-shadow: 0 3px 8px rgba(255, 152, 0, 0.4);
        }

        .keyframe.selected .keyframe-handle:hover {
            background: #ffe0b2;
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.6);
        }

        .keyframe.hover-highlight {
            background: linear-gradient(90deg, #4dd0e1, #26c6da);
            border-color: rgba(255, 255, 255, 0.7);
            box-shadow: 0 4px 16px rgba(77, 208, 225, 0.6);
            height: 8px;
            transform: translateY(-50%) scale(1.1);
        }

                .keyframe.hover-highlight::before {
            background: linear-gradient(90deg,
                rgba(255, 255, 255, 0.3) 0%,
                rgba(255, 255, 255, 0.2) 50%,
                rgba(255, 255, 255, 0.3) 100%);
            opacity: 1;
        }

        .track-timeline:hover {
            background: rgba(0, 188, 212, 0.03);
        }

        .keyframe.snap-highlight {
            border: 2px solid #ffeb3b;
            box-shadow: 0 4px 20px rgba(255, 235, 59, 0.8);
            animation: snapPulse 0.5s ease-in-out;
        }

        @keyframes snapPulse {
            0% { transform: translateY(-50%) scale(1); }
            50% { transform: translateY(-50%) scale(1.05); }
            100% { transform: translateY(-50%) scale(1); }
        }

        .keyframe.connected-start {
            border-left: 3px solid #4caf50;
        }

        .keyframe.connected-end {
            border-right: 3px solid #4caf50;
        }

        .keyframe-handle:active {
            cursor: grabbing;
        }

        .keyframe-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .keyframe-tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }



        .playhead {
            position: absolute;
            top: 0;
            width: 2px;
            background: #ff4444;
            z-index: 100;
            height: 100%;
            cursor: ew-resize;
        }

        .playhead-handle {
            position: absolute;
            top: 4px;
            left: -6px;
            width: 12px;
            height: 12px;
            background: #ff4444;
            border: 2px solid #ffffff;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px rgba(255, 68, 68, 0.5);
            z-index: 101;
        }

        .playhead-handle:active {
            cursor: grabbing;
        }

        .playhead-frame-display {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
            margin-bottom: 8px;
            border: 1px solid #ff4444;
            z-index: 102;
        }

        .editor-sidebar {
            width: 300px;
            min-width: 300px;
            max-width: 300px;
            background: rgba(20, 20, 35, 0.9);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .sidebar-header {
            background: rgba(255, 255, 255, 0.05);
            padding: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-title {
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }

        .sidebar-content {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
        }

        .keyframe-editor {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .keyframe-editor h4 {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            margin: 0 0 12px 0;
        }

        .editor-field {
            margin-bottom: 12px;
        }

        .editor-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .editor-field label {
            display: block;
            font-size: 12px;
            color: #a0a0a0;
            margin-bottom: 4px;
            font-weight: 500;
        }

        .editor-field input,
        .editor-field select {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px 10px;
            color: #ffffff;
            font-size: 13px;
        }

        .editor-field input:focus,
        .editor-field select:focus {
            outline: none;
            border-color: #00bcd4;
            box-shadow: 0 0 0 2px rgba(0, 188, 212, 0.2);
        }

        .easing-presets {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 8px;
        }

        .easing-preset {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 11px;
            color: #ffffff;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
        }

        .easing-preset:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .easing-preset.active {
            background: rgba(0, 188, 212, 0.3);
            border-color: #00bcd4;
        }

        .editor-actions {
            padding: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 8px;
        }

        .btn {
            flex: 1;
            background: linear-gradient(135deg, #00bcd4, #009688);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 188, 212, 0.3);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
            transition: left 0.5s;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(0, 188, 212, 0.4);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:active {
            transform: translateY(0);
            transition: transform 0.1s;
        }

        .btn-editor {
            flex: 1;
            background: linear-gradient(135deg, #4caf50, #45a049);
            border: none;
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .btn-editor:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .btn-editor.secondary {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }

        .btn-editor.secondary:hover {
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.3);
        }

        /* Easing Curve Preview */
        .curve-preview {
            position: fixed;
            background: rgba(10, 10, 20, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.2s ease;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .curve-preview.show {
            opacity: 1;
            transform: translateY(0);
        }

        .curve-preview-title {
            font-size: 11px;
            color: #a0a0a0;
            margin-bottom: 8px;
            text-align: center;
            font-weight: 500;
        }

        .curve-svg {
            width: 120px;
            height: 80px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .curve-path {
            fill: none;
            stroke: #64ffda;
            stroke-width: 2;
            stroke-linecap: round;
        }

        .curve-grid {
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 0.5;
        }

        .curve-handles {
            fill: #ff9800;
            stroke: #ffffff;
            stroke-width: 1;
        }

        /* Timeline scrollbar */
        .timeline-ruler::-webkit-scrollbar,
        .timeline-tracks::-webkit-scrollbar {
            height: 8px;
            width: 8px;
        }

        .timeline-ruler::-webkit-scrollbar-track,
        .timeline-tracks::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        .timeline-ruler::-webkit-scrollbar-thumb,
        .timeline-tracks::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        .timeline-ruler::-webkit-scrollbar-thumb:hover,
        .timeline-tracks::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }


    </style>
</head>
<body>
    <div class="editor-modal" id="editorContainer">
        <div class="editor-content">
            <div class="editor-header">
                <h2 class="editor-title">üé¨ Animation Editor</h2>
                <div class="editor-controls">
                    <button id="editorPlayBtn" class="btn">‚ñ∂ Play</button>
                    <button id="editorPauseBtn" class="btn">‚è∏ Pause</button>
                    <button id="editorResetBtn" class="btn">‚èπ Reset</button>
                    <button class="editor-close" onclick="closeEditor()">‚úï Close</button>
                </div>
            </div>
            <div class="editor-body">
                <div class="editor-timeline">
                    <div class="timeline-header">
                        <div class="timeline-config">
                            <div class="config-group">
                                <span class="config-label">Frame Rate:</span>
                                <input type="number" id="editorFrameRate" class="config-input" value="60" min="1" max="120">
                            </div>
                            <div class="config-group">
                                <span class="config-label">Start:</span>
                                <input type="number" id="editorStartFrame" class="config-input" value="0" min="0">
                            </div>
                            <div class="config-group">
                                <span class="config-label">End:</span>
                                <input type="number" id="editorEndFrame" class="config-input" value="200" min="1">
                            </div>
                            <div class="config-group">
                                <label style="display: flex; align-items: center; gap: 6px; color: #a0a0a0; font-size: 12px;">
                                    <input type="checkbox" id="editorLoop" checked style="margin: 0;">
                                    Loop
                                </label>
                            </div>
                            <div class="config-group">
                                <span class="config-label">Zoom:</span>
                                <span id="zoomLevel" class="config-label" style="color: #64ffda;">5px/frame</span>
                            </div>
                            <div class="config-group">
                                <span class="config-label" style="font-size: 11px; color: #888;" title="Keyboard Shortcuts: Space=Play/Pause, ‚Üê/‚Üí=Step Frame, Shift+‚Üê/‚Üí=Jump Keyframes, Home/End=Start/End">‚å®Ô∏è Shortcuts</span>
                            </div>
                        </div>
                    </div>
                    <div class="timeline-ruler" id="timelineRuler">
                        <div class="ruler-marks" id="rulerMarks"></div>
                    </div>
                    <div class="timeline-tracks" id="timelineTracks">
                        <div class="property-track" data-property="brightness">
                            <div class="track-label">
                                <span class="track-name">üí° Brightness</span>
                                <span class="track-value" id="trackBrightness">50%</span>
                            </div>
                            <div class="track-timeline" id="brightnessTrack"></div>
                        </div>
                        <div class="property-track" data-property="rotation">
                            <div class="track-label">
                                <span class="track-name">üîÑ Rotation</span>
                                <span class="track-value" id="trackRotation">180¬∞</span>
                            </div>
                            <div class="track-timeline" id="rotationTrack"></div>
                        </div>
                        <div class="property-track" data-property="tilt">
                            <div class="track-label">
                                <span class="track-name">‚ÜïÔ∏è Tilt</span>
                                <span class="track-value" id="trackTilt">0¬∞</span>
                            </div>
                            <div class="track-timeline" id="tiltTrack"></div>
                        </div>
                        <div class="playhead" id="playhead" style="left: 120px;">
                            <div class="playhead-handle" id="playheadHandle"></div>
                            <div class="playhead-frame-display" id="playheadFrameDisplay">Frame 0</div>
                        </div>
                    </div>
                </div>
                <div class="editor-sidebar">
                    <div class="sidebar-header">
                        <h3 class="sidebar-title">Keyframe Editor</h3>
                    </div>
                    <div class="sidebar-content" id="sidebarContent">
                        <!-- Keyframe Editor - Shows when keyframe selected -->
                        <div id="keyframeEditorSection" style="display: none;"></div>

                        <!-- No Selection Message -->
                        <div id="noKeyframeSelected" style="text-align: center; color: #888; padding: 20px;">
                            Click on a keyframe or add a new one to edit properties
                        </div>
                    </div>
                    <div class="editor-actions">
                        <button id="addKeyframeBtn" class="btn-editor">+ Add Keyframe</button>
                        <button id="deleteKeyframeBtn" class="btn-editor secondary">üóë Delete</button>
                    </div>
                    <div class="editor-actions">
                        <button id="exportJsonBtn" class="btn-editor">üì§ Export JSON</button>
                        <button id="loadToViewerBtn" class="btn-editor secondary">‚ñ∂ Load to Viewer</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Curve Preview Tooltip -->
    <div id="curvePreview" class="curve-preview" style="display: none;">
        <div class="curve-preview-title" id="curveTitle">Ease</div>
        <svg class="curve-svg" id="curveSvg" viewBox="0 0 100 80">
            <!-- Grid lines -->
            <defs>
                <pattern id="grid" width="10" height="8" patternUnits="userSpaceOnUse">
                    <path d="M 10 0 L 0 0 0 8" fill="none" class="curve-grid"/>
                </pattern>
            </defs>
            <rect width="100" height="80" fill="url(#grid)"/>

            <!-- Curve path -->
            <path id="curvePath" class="curve-path" d="M 10,70 Q 35,70 90,10"/>

            <!-- Control points -->
            <circle class="curve-handles" cx="10" cy="70" r="2"/>
            <circle class="curve-handles" cx="90" cy="10" r="2"/>
            <circle id="handle1" class="curve-handles" cx="35" cy="70" r="2"/>
            <circle id="handle2" class="curve-handles" cx="65" cy="40" r="2"/>
        </svg>
    </div>



    <script>
        // Global variables - storing as independent segments
        let editorKeyframes = {
            brightness: [],
            rotation: [],
            tilt: []
        };
        let selectedKeyframe = null;
        let editorCurrentFrame = 0;
        let editorIsPlaying = false;
        let editorStartTime = 0;
        let editorAnimationId = null;
        let hasLoadedFromParent = false;
        let timelineWidth = 1000;
        let pixelsPerFrame = 5;
        let isDraggingPlayhead = false;
        let dragStartX = 0;
        let dragStartFrame = 0;

        // DOM elements
        const editorPlayBtn = document.getElementById('editorPlayBtn');
        const editorPauseBtn = document.getElementById('editorPauseBtn');
        const editorResetBtn = document.getElementById('editorResetBtn');
        const editorFrameRate = document.getElementById('editorFrameRate');
        const editorStartFrame = document.getElementById('editorStartFrame');
        const editorEndFrame = document.getElementById('editorEndFrame');
        const editorLoop = document.getElementById('editorLoop');
        const timelineRuler = document.getElementById('timelineRuler');
        const rulerMarks = document.getElementById('rulerMarks');
        const playhead = document.getElementById('playhead');
        const timelineTracks = document.getElementById('timelineTracks');
        const brightnessTrack = document.getElementById('brightnessTrack');
        const rotationTrack = document.getElementById('rotationTrack');
        const tiltTrack = document.getElementById('tiltTrack');
        const sidebarContent = document.getElementById('sidebarContent');
        const addKeyframeBtn = document.getElementById('addKeyframeBtn');
        const deleteKeyframeBtn = document.getElementById('deleteKeyframeBtn');
        const exportJsonBtn = document.getElementById('exportJsonBtn');
        const loadToViewerBtn = document.getElementById('loadToViewerBtn');
        const zoomLevel = document.getElementById('zoomLevel');
        const playheadHandle = document.getElementById('playheadHandle');
        const playheadFrameDisplay = document.getElementById('playheadFrameDisplay');
        const trackBrightness = document.getElementById('trackBrightness');
        const trackRotation = document.getElementById('trackRotation');
        const trackTilt = document.getElementById('trackTilt');
        const keyframeEditorSection = document.getElementById('keyframeEditorSection');
        const noKeyframeSelected = document.getElementById('noKeyframeSelected');
        const curvePreview = document.getElementById('curvePreview');
        const curveTitle = document.getElementById('curveTitle');
        const curvePath = document.getElementById('curvePath');
        const handle1 = document.getElementById('handle1');
        const handle2 = document.getElementById('handle2');


        // Animation schema data
        const animationSchema = {
            "$schema": "http://json-schema.org/draft-07/schema#",
            "title": "Robot Animation Configuration Schema",
            "type": "object",
            "required": ["frameRate", "startFrame", "endFrame", "loop"],
            "properties": {
                "frameRate": {
                    "type": "number",
                    "minimum": 1,
                    "maximum": 120,
                    "description": "Animation playback rate in frames per second"
                },
                "startFrame": {
                    "type": "number",
                    "minimum": 0,
                    "description": "Starting frame number of the animation"
                },
                "endFrame": {
                    "type": "number",
                    "minimum": 0,
                    "description": "Ending frame number of the animation"
                },
                "loop": {
                    "type": "boolean",
                    "description": "Whether the animation should loop continuously"
                },
                "brightness": {
                    "$ref": "#/definitions/animationProperty",
                    "description": "Brightness Property animation configuration range [0.0, 100.0]"
                },
                "rotation": {
                    "$ref": "#/definitions/animationProperty",
                    "description": "Motor Rotation Property animation configuration range [0, 359] , 180 degree means robot facing-forward. the value is defined as absolute and mesured counter-clockwise"
                },
                "tilt": {
                    "$ref": "#/definitions/animationProperty",
                    "description": "Motor Tilt Property animation configuration range [-30, 90], -ve value => tilt downward, +ve value => tilt upward. 0 => horizontal plane"
                }
            },
            "definitions": {
                "animationProperty": {
                    "type": "object",
                    "required": ["animation", "keyframe"],
                    "properties": {
                        "animation": {
                            "type": "boolean",
                            "description": "Whether this property should be animated"
                        },
                        "keyframe": {
                            "type": "array",
                            "description": "Array of keyframes defining the animation",
                            "items": {
                                "type": "object",
                                "required": ["from_frame", "to_frame", "from_value", "to_value", "bezier"],
                                "properties": {
                                    "from_frame": {
                                        "type": "number",
                                        "minimum": 0,
                                        "description": "Starting frame of this keyframe segment"
                                    },
                                    "to_frame": {
                                        "type": "number",
                                        "minimum": 0,
                                        "description": "Ending frame of this keyframe segment"
                                    },
                                    "from_value": {
                                        "type": "number",
                                        "description": "Starting value of this keyframe segment"
                                    },
                                    "to_value": {
                                        "type": "number",
                                        "description": "Ending value of this keyframe segment"
                                    },
                                    "bezier": {
                                        "type": "array",
                                        "description": "Bezier curve control points for interpolation, The array contains P1(OutTangent) and P2(Intangent) points of a cubic bezier curve where P1(0.0,0.0), P3(1.0, 1.0) ",
                                        "items": {
                                            "type": "number",
                                            "minimum": 0,
                                            "maximum": 1
                                        },
                                        "minItems": 4,
                                        "maxItems": 4
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };

                                // Initialize the editor
        function init() {
            // Detect if we're in an iframe and apply appropriate styling
            if (window.parent !== window) {
                document.body.classList.add('iframe-mode');

                // Update button text for iframe mode
                const loadBtn = document.getElementById('loadToViewerBtn');
                if (loadBtn) {
                    loadBtn.textContent = '‚ñ∂ Send to Viewer';
                }

                // Listen for animation data from parent
                window.addEventListener('message', function(event) {
                    if (event.data && event.data.type === 'loadCurrentAnimation') {
                        if (event.data.animation) {
                            loadAnimationFromParent(event.data.animation);
                        } else {
                            // No animation data from parent, load defaults
                            loadDefaultKeyframes();
                        }
                    }
                });

                // Request current animation from parent
                window.parent.postMessage({
                    type: 'requestCurrentAnimation'
                }, '*');
            }

            editorCurrentFrame = parseInt(editorStartFrame.value);
            initializeTimeline();

            // In iframe mode, wait briefly for parent to send data before loading defaults
            if (window.parent !== window) {
                setTimeout(() => {
                    if (!hasLoadedFromParent) {
                        console.log('No animation received from parent, loading defaults');
                        loadDefaultKeyframes();
                    }
                }, 500); // Increased timeout to give parent more time to respond
            } else {
                // Standalone mode - load defaults immediately
                loadDefaultKeyframes();
            }

            setupEventListeners();

            // Auto-focus the editor for keyboard shortcuts
            document.body.tabIndex = 0;
            document.body.focus();

            // Initialize sidebar state
            selectedKeyframe = null;
            updateSidebar();
        }

        function setupEventListeners() {
            // Control buttons
            editorPlayBtn.addEventListener('click', playEditorAnimation);
            editorPauseBtn.addEventListener('click', pauseEditorAnimation);
            editorResetBtn.addEventListener('click', resetEditorAnimation);
            addKeyframeBtn.addEventListener('click', addKeyframe);
            deleteKeyframeBtn.addEventListener('click', deleteSelectedKeyframe);
            exportJsonBtn.addEventListener('click', exportAnimationJson);
            loadToViewerBtn.addEventListener('click', loadToViewer);

            // Timeline configuration listeners
            editorFrameRate.addEventListener('change', updateTimelineConfig);
            editorStartFrame.addEventListener('change', updateTimelineConfig);
            editorEndFrame.addEventListener('change', updateTimelineConfig);

            // Timeline interaction listeners are now handled by setupPropertyTrackHover()

            // Timeline ruler click for scrubbing
            timelineRuler.addEventListener('click', handleRulerClick);

            // Sync scrolling between ruler and tracks
            timelineRuler.addEventListener('scroll', () => {
                timelineTracks.scrollLeft = timelineRuler.scrollLeft;
            });
            timelineTracks.addEventListener('scroll', () => {
                timelineRuler.scrollLeft = timelineTracks.scrollLeft;
            });

            // Playhead dragging
            playheadHandle.addEventListener('mousedown', startDragPlayhead);
            playhead.addEventListener('mousedown', startDragPlayhead);
            document.addEventListener('mousemove', dragPlayhead);
            document.addEventListener('mouseup', stopDragPlayhead);

            // Keyboard shortcuts for editor
            document.addEventListener('keydown', handleEditorKeydown);

            // Property track hover effects
            setupPropertyTrackHover();
        }

                function setupPropertyTrackHover() {
            const propertyTracks = document.querySelectorAll('.property-track');

            propertyTracks.forEach(track => {
                const property = track.dataset.property;
                const timeline = track.querySelector('.track-timeline');

                // Add hover effects to highlight specific segment under mouse
                timeline.addEventListener('mousemove', (e) => {
                    const rect = timeline.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const startFrame = parseInt(editorStartFrame.value);
                    const hoverFrame = Math.round(startFrame + (x / pixelsPerFrame));

                    // Clear all previous hover highlights for this property
                    clearPropertyHoverHighlights(property);

                    // Find segment under mouse and highlight it
                    const hoveredSegment = findSegmentAtFrame(property, hoverFrame);
                    if (hoveredSegment) {
                        highlightSpecificSegment(property, hoveredSegment.index, true);
                        track.classList.add('hover-highlight');
                    } else {
                        track.classList.remove('hover-highlight');
                    }
                });

                timeline.addEventListener('mouseleave', () => {
                    clearPropertyHoverHighlights(property);
                    track.classList.remove('hover-highlight');
                });

                // Add click handler for segment selection or creation
                timeline.addEventListener('click', (e) => {
                    if (e.target.classList.contains('keyframe') || e.target.classList.contains('keyframe-handle')) {
                        return; // Let existing keyframe handlers deal with it
                    }

                    const rect = timeline.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const startFrame = parseInt(editorStartFrame.value);
                    const clickFrame = Math.round(startFrame + (x / pixelsPerFrame));

                    // Check if there's a segment at this frame
                    const existingSegment = findSegmentAtFrame(property, clickFrame);

                    if (existingSegment) {
                        // Select the existing segment
                        selectKeyframe(property, existingSegment.index);
                    } else {
                        // Add new segment at this position
                        addKeyframeAtFrame(property, clickFrame);
                    }
                });
            });
        }

        function highlightSpecificSegment(property, segmentIndex, highlight) {
            const keyframe = document.querySelector(`[data-property="${property}"][data-index="${segmentIndex}"].keyframe`);
            if (keyframe) {
                if (highlight) {
                    keyframe.classList.add('hover-highlight');
                } else {
                    keyframe.classList.remove('hover-highlight');
                }
            }
        }

        function clearPropertyHoverHighlights(property) {
            const keyframes = document.querySelectorAll(`[data-property="${property}"].keyframe`);
            keyframes.forEach(keyframe => {
                keyframe.classList.remove('hover-highlight');
            });
        }

        function findSegmentAtFrame(property, frame) {
            const segments = editorKeyframes[property];
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                if (frame >= segment.startFrame && frame <= segment.endFrame) {
                    return { segment, index: i };
                }
            }
            return null;
        }

        function initializeTimeline() {
            updateTimelineConfig();
            renderTimeline();
            updatePlayhead();
        }

        function updateTimelineConfig() {
            const startFrame = parseInt(editorStartFrame.value);
            const endFrame = parseInt(editorEndFrame.value);
            const totalFrames = endFrame - startFrame + 1;

            // Adaptive pixels per frame based on animation length
            if (totalFrames <= 200) {
                pixelsPerFrame = 5;
            } else if (totalFrames <= 500) {
                pixelsPerFrame = 3;
            } else if (totalFrames <= 1000) {
                pixelsPerFrame = 2;
            } else {
                pixelsPerFrame = 1;
            }

            timelineWidth = Math.max(totalFrames * pixelsPerFrame, 1000);

            // Update zoom level display
            if (zoomLevel) {
                zoomLevel.textContent = `${pixelsPerFrame}px/frame`;
                if (totalFrames > 200) {
                    zoomLevel.title = `Auto-scaled for ${totalFrames} frames`;
                } else {
                    zoomLevel.title = '';
                }
            }

            renderTimeline();
        }

        function renderTimeline() {
            const startFrame = parseInt(editorStartFrame.value);
            const endFrame = parseInt(editorEndFrame.value);
            const trackLabelWidth = 120; // Width of the track labels

            // Update ruler
            rulerMarks.style.width = (timelineWidth + trackLabelWidth) + 'px';
            rulerMarks.innerHTML = '';

            // Adaptive frame mark interval based on animation length
            const totalFrames = endFrame - startFrame + 1;
            let markInterval;
            if (totalFrames <= 200) {
                markInterval = 10;
            } else if (totalFrames <= 500) {
                markInterval = 25;
            } else if (totalFrames <= 1000) {
                markInterval = 50;
            } else {
                markInterval = 100;
            }

            for (let frame = startFrame; frame <= endFrame; frame += markInterval) {
                const mark = document.createElement('div');
                mark.className = 'frame-mark';
                mark.style.left = (trackLabelWidth + (frame - startFrame) * pixelsPerFrame) + 'px';

                const number = document.createElement('span');
                number.className = 'frame-number';
                number.textContent = frame;
                mark.appendChild(number);

                rulerMarks.appendChild(mark);
            }

            // Update track widths
            [brightnessTrack, rotationTrack, tiltTrack].forEach(track => {
                track.style.width = timelineWidth + 'px';
            });

            renderKeyframes();
        }

                                        function renderKeyframes() {
            // Clear existing keyframes
            document.querySelectorAll('.keyframe').forEach(kf => kf.remove());

            const startFrame = parseInt(editorStartFrame.value);

            // Render keyframes for each property
            Object.keys(editorKeyframes).forEach(property => {
                const track = document.getElementById(property + 'Track');
                const segments = editorKeyframes[property];

                // Render each independent segment
                segments.forEach((segment, index) => {
                    const keyframeEl = document.createElement('div');
                    keyframeEl.className = 'keyframe';

                    // Calculate position and width for the line segment
                    const startX = (segment.startFrame - startFrame) * pixelsPerFrame;
                    const endX = (segment.endFrame - startFrame) * pixelsPerFrame;
                    const width = endX - startX;

                    keyframeEl.style.left = startX + 'px';
                    keyframeEl.style.width = width + 'px';
                    keyframeEl.dataset.property = property;
                    keyframeEl.dataset.index = index;
                    keyframeEl.dataset.startFrame = segment.startFrame;
                    keyframeEl.dataset.endFrame = segment.endFrame;
                    keyframeEl.dataset.startValue = segment.startValue;
                    keyframeEl.dataset.endValue = segment.endValue;

                    // Check for connections with other segments
                    const isConnectedStart = segments.some(other => other !== segment && other.endFrame === segment.startFrame);
                    const isConnectedEnd = segments.some(other => other !== segment && other.startFrame === segment.endFrame);

                    if (isConnectedStart) {
                        keyframeEl.classList.add('connected-start');
                    }
                    if (isConnectedEnd) {
                        keyframeEl.classList.add('connected-end');
                    }

                    // Add handles at start and end of the line
                    const startHandle = document.createElement('div');
                    startHandle.className = 'keyframe-handle';
                    startHandle.style.left = '0px';
                    startHandle.dataset.handleType = 'start';
                    startHandle.dataset.keyframeIndex = index;

                    const endHandle = document.createElement('div');
                    endHandle.className = 'keyframe-handle';
                    endHandle.style.left = '100%';
                    endHandle.dataset.handleType = 'end';
                    endHandle.dataset.keyframeIndex = index;

                    keyframeEl.appendChild(startHandle);
                    keyframeEl.appendChild(endHandle);

                    keyframeEl.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('keyframe-handle')) {
                            e.stopPropagation();
                            selectKeyframe(property, index);
                        }
                    });

                    // Add tooltip functionality
                    keyframeEl.addEventListener('mouseenter', (e) => {
                        showKeyframeTooltip(e, property, index, segment);
                    });

                    keyframeEl.addEventListener('mouseleave', hideKeyframeTooltip);

                    // Handle events for the handles
                    [startHandle, endHandle].forEach(handle => {
                        handle.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const handleType = handle.dataset.handleType;
                            const keyframeIndex = parseInt(handle.dataset.keyframeIndex);
                            selectKeyframeHandle(property, keyframeIndex, handleType);
                        });
                    });

                    track.appendChild(keyframeEl);
                });
            });
        }



        function handleRulerClick(event) {
            if (event.target.classList.contains('playhead-handle')) return;

            const rect = timelineRuler.getBoundingClientRect();
            const x = event.clientX - rect.left - 120; // Account for track label width
            const startFrame = parseInt(editorStartFrame.value);
            const endFrame = parseInt(editorEndFrame.value);
            const frame = Math.max(startFrame, Math.min(endFrame, Math.round(startFrame + (x / pixelsPerFrame))));

            editorCurrentFrame = frame;
            updatePlayhead();
                }

        function getConnectedSegmentValues(segments, startFrame, endFrame, defaultValue) {
            let startValue = defaultValue;
            let endValue = defaultValue;

            // Check if start frame connects to end of another segment
            for (const segment of segments) {
                if (segment.endFrame === startFrame) {
                    startValue = segment.endValue;
                    break;
                }
            }

            // Check if end frame connects to start of another segment
            for (const segment of segments) {
                if (segment.startFrame === endFrame) {
                    endValue = segment.startValue;
                    break;
                }
            }

            return { startValue, endValue };
        }

        function addKeyframeAtFrame(property, frame) {
            const defaultValues = {
                brightness: 50,
                rotation: 180,
                tilt: 0
            };

            const segments = editorKeyframes[property];

            // Find a suitable end frame that doesn't overlap with existing segments
            let endFrame = frame + 30; // Default 30 frame duration

            // Check if the proposed segment would overlap with existing ones
            let foundValidEnd = false;
            for (let duration = 30; duration >= 5; duration -= 5) {
                const proposedEnd = frame + duration;
                if (isSegmentValid(segments, -1, frame, proposedEnd)) {
                    endFrame = proposedEnd;
                    foundValidEnd = true;
                    break;
                }
            }

            // If we can't find a valid end frame, try to find a gap
            if (!foundValidEnd) {
                // Look for the next available start frame after the clicked frame
                const sortedSegments = [...segments].sort((a, b) => a.startFrame - b.startFrame);
                let nextAvailableFrame = frame;

                for (const segment of sortedSegments) {
                    if (nextAvailableFrame < segment.startFrame) {
                        // Found a gap before this segment
                        endFrame = Math.min(nextAvailableFrame + 30, segment.startFrame);
                        if (endFrame > nextAvailableFrame) {
                            frame = nextAvailableFrame;
                            foundValidEnd = true;
                            break;
                        }
                    }
                    nextAvailableFrame = Math.max(nextAvailableFrame, segment.endFrame);
                }

                // If still no valid position, place after the last segment
                if (!foundValidEnd && sortedSegments.length > 0) {
                    frame = sortedSegments[sortedSegments.length - 1].endFrame;
                    endFrame = frame + 30;
                    foundValidEnd = true;
                }
            }

            if (!foundValidEnd) {
                alert('Cannot add segment here - no space available without overlapping!');
                return;
            }

            // Apply snapping to connect with adjacent segments
            const snappedFrames = snapToAdjacentSegments(segments, -1, frame, endFrame);
            frame = snappedFrames.startFrame;
            endFrame = snappedFrames.endFrame;

            // Get appropriate start and end values for connected segments
            const segmentValues = getConnectedSegmentValues(segments, frame, endFrame, defaultValues[property]);

            // Create a new segment with validated frames and connected values
            const newSegment = {
                startFrame: frame,
                endFrame: endFrame,
                startValue: segmentValues.startValue,
                endValue: segmentValues.endValue,
                easing: [0.42, 0.0, 0.58, 1.0]
            };

            // Add the segment
            segments.push(newSegment);

            // Sort segments by start frame to maintain chronological order
            segments.sort((a, b) => a.startFrame - b.startFrame);

            // Apply value connections for adjacent segments
            const newIndex = segments.findIndex(s => s === newSegment);
            connectAdjacentSegmentValues(segments, newIndex);

            // Enforce exact alignment for close segments
            enforceExactAlignment(segments);

            renderKeyframes();

            // Select the new segment
            const segmentIndex = segments.findIndex(s => s.startFrame === frame);
            if (segmentIndex !== -1) {
                selectKeyframe(property, segmentIndex);
            }

            updateCurrentFrameValues();
        }

        function addKeyframe() {
            if (!selectedKeyframe) {
                // Add keyframe at current frame for brightness by default
                addKeyframeAtFrame('brightness', editorCurrentFrame);
            } else {
                // Add keyframe for selected property
                addKeyframeAtFrame(selectedKeyframe.property, editorCurrentFrame);
            }
        }

                                                function deleteSelectedKeyframe() {
            if (!selectedKeyframe) return;

            const segments = editorKeyframes[selectedKeyframe.property];

            // Delete the selected segment
            segments.splice(selectedKeyframe.index, 1);

            selectedKeyframe = null;
            renderKeyframes();
            updateSidebar();
            updateCurrentFrameValues();
        }

        function selectKeyframe(property, index) {
            // Clear previous selection
            document.querySelectorAll('.keyframe.selected').forEach(kf => {
                kf.classList.remove('selected');
            });

            // Select new keyframe
            const keyframeEl = document.querySelector(`[data-property="${property}"][data-index="${index}"]`);
            if (keyframeEl) {
                keyframeEl.classList.add('selected');
                selectedKeyframe = { property, index, type: 'segment' };
                updateSidebar();
            }
        }

        function selectKeyframeHandle(property, index, handleType) {
            // Clear previous selection
            document.querySelectorAll('.keyframe.selected').forEach(kf => {
                kf.classList.remove('selected');
            });

            // Select the keyframe segment and highlight the specific handle
            const keyframeEl = document.querySelector(`[data-property="${property}"][data-index="${index}"]`);
            if (keyframeEl) {
                keyframeEl.classList.add('selected');
                selectedKeyframe = { property, index, type: 'handle', handleType };
                updateSidebar();
            }
        }



                                function updateSidebar() {
            if (!selectedKeyframe) {
                keyframeEditorSection.style.display = 'none';
                noKeyframeSelected.style.display = 'block';
                return;
            }

            noKeyframeSelected.style.display = 'none';
            keyframeEditorSection.style.display = 'block';

            const segments = editorKeyframes[selectedKeyframe.property];
            const segment = segments[selectedKeyframe.index];

            const propertyInfo = {
                brightness: { name: 'Brightness', min: 0, max: 100, unit: '%' },
                rotation: { name: 'Rotation', min: 0, max: 359, unit: '¬∞' },
                tilt: { name: 'Tilt', min: -30, max: 90, unit: '¬∞' }
            };

            const info = propertyInfo[selectedKeyframe.property];

            let title = `${info.name} Keyframe Segment`;
            if (selectedKeyframe.type === 'handle') {
                title += ` (${selectedKeyframe.handleType === 'start' ? 'Start' : 'End'} Handle)`;
            }

            keyframeEditorSection.innerHTML = `
                <div class="keyframe-editor">
                    <h4>${title}</h4>
                    <div class="editor-row">
                        <div class="editor-field">
                            <label>Start Frame</label>
                            <input type="number" id="keyframeStartFrame" value="${segment.startFrame}" min="0">
                        </div>
                        <div class="editor-field">
                            <label>End Frame</label>
                            <input type="number" id="keyframeEndFrame" value="${segment.endFrame}" min="0">
                        </div>
                    </div>
                    <div class="editor-row">
                        <div class="editor-field">
                            <label>Start Value (${info.unit})</label>
                            <input type="number" id="keyframeStartValue" value="${segment.startValue}" min="${info.min}" max="${info.max}" step="0.1">
                        </div>
                        <div class="editor-field">
                            <label>End Value (${info.unit})</label>
                            <input type="number" id="keyframeEndValue" value="${segment.endValue}" min="${info.min}" max="${info.max}" step="0.1">
                        </div>
                    </div>
                    <div class="editor-field">
                        <label>Easing</label>
                        <div class="easing-presets">
                            <div class="easing-preset" data-easing="0.42,0.0,0.58,1.0">Ease</div>
                            <div class="easing-preset" data-easing="0.42,0.0,1.0,1.0">Ease Out</div>
                            <div class="easing-preset" data-easing="0.0,0.0,0.58,1.0">Ease In</div>
                            <div class="easing-preset" data-easing="0.25,0.1,0.25,1.0">Ease In-Out</div>
                        </div>
                        <input type="text" id="keyframeEasing" value="${segment.easing.join(',')}" placeholder="p1x,p1y,p2x,p2y">
                    </div>
                </div>
            `;

            // Add event listeners
            document.getElementById('keyframeStartFrame').addEventListener('change', updateKeyframeProperty);
            document.getElementById('keyframeEndFrame').addEventListener('change', updateKeyframeProperty);
            document.getElementById('keyframeStartValue').addEventListener('change', updateKeyframeProperty);
            document.getElementById('keyframeEndValue').addEventListener('change', updateKeyframeProperty);
            document.getElementById('keyframeEasing').addEventListener('change', updateKeyframeProperty);

            // Easing preset listeners - need to use setTimeout to ensure DOM is ready
            setTimeout(() => {
                const presets = keyframeEditorSection.querySelectorAll('.easing-preset');
                console.log('Found easing presets:', presets.length); // Debug log

                presets.forEach(preset => {
                    preset.addEventListener('click', () => {
                        document.getElementById('keyframeEasing').value = preset.dataset.easing;
                        updateKeyframeProperty();
                    });

                    // Add curve preview on hover
                    preset.addEventListener('mouseenter', (e) => {
                        console.log('Hover detected on:', preset.textContent); // Debug log
                        const easingValues = preset.dataset.easing.split(',').map(v => parseFloat(v));
                        const presetName = preset.textContent;
                        showCurvePreview(e, easingValues, presetName);
                    });

                    preset.addEventListener('mouseleave', hideCurvePreview);
                });
            }, 10);

            // Highlight current easing
            const currentEasing = keyframe.easing.join(',');
            document.querySelectorAll('.easing-preset').forEach(preset => {
                if (preset.dataset.easing === currentEasing) {
                    preset.classList.add('active');
                }
            });

            // Add curve preview to custom input
            addCustomEasingPreview();
        }

                                                                function isSegmentValid(segments, currentIndex, startFrame, endFrame) {
            // Ensure start frame is before end frame
            if (startFrame >= endFrame) {
                return false;
            }

            // Check for overlaps with other segments
            for (let i = 0; i < segments.length; i++) {
                if (i === currentIndex) continue; // Skip current segment

                const otherSegment = segments[i];

                // Check if segments overlap (not just touching)
                const hasOverlap = (
                    (startFrame > otherSegment.startFrame && startFrame < otherSegment.endFrame) ||
                    (endFrame > otherSegment.startFrame && endFrame < otherSegment.endFrame) ||
                    (startFrame <= otherSegment.startFrame && endFrame >= otherSegment.endFrame)
                );

                if (hasOverlap) {
                    return false;
                }
            }

            return true;
        }

        function snapToAdjacentSegments(segments, currentIndex, startFrame, endFrame) {
            const SNAP_THRESHOLD = 8; // Increased threshold for easier snapping
            let snappedStart = startFrame;
            let snappedEnd = endFrame;

            // Find the closest snap points for start and end frames
            let bestStartSnap = null;
            let bestEndSnap = null;
            let bestStartDistance = SNAP_THRESHOLD + 1;
            let bestEndDistance = SNAP_THRESHOLD + 1;

            // Check all other segments for snapping opportunities
            for (let i = 0; i < segments.length; i++) {
                if (i === currentIndex) continue;

                const otherSegment = segments[i];

                // Check start frame snapping opportunities
                const startToEnd = Math.abs(startFrame - otherSegment.endFrame);
                const startToStart = Math.abs(startFrame - otherSegment.startFrame);

                if (startToEnd <= SNAP_THRESHOLD && startToEnd < bestStartDistance) {
                    bestStartSnap = otherSegment.endFrame;
                    bestStartDistance = startToEnd;
                }

                if (startToStart <= SNAP_THRESHOLD && startToStart < bestStartDistance) {
                    bestStartSnap = otherSegment.startFrame;
                    bestStartDistance = startToStart;
                }

                // Check end frame snapping opportunities
                const endToStart = Math.abs(endFrame - otherSegment.startFrame);
                const endToEnd = Math.abs(endFrame - otherSegment.endFrame);

                if (endToStart <= SNAP_THRESHOLD && endToStart < bestEndDistance) {
                    bestEndSnap = otherSegment.startFrame;
                    bestEndDistance = endToStart;
                }

                if (endToEnd <= SNAP_THRESHOLD && endToEnd < bestEndDistance) {
                    bestEndSnap = otherSegment.endFrame;
                    bestEndDistance = endToEnd;
                }
            }

            // Apply the best snaps found
            if (bestStartSnap !== null) {
                snappedStart = bestStartSnap;
            }
            if (bestEndSnap !== null) {
                snappedEnd = bestEndSnap;
            }

            return { startFrame: snappedStart, endFrame: snappedEnd };
        }

                function connectAdjacentSegmentValues(segments, currentIndex) {
            const currentSegment = segments[currentIndex];

            // Sort segments by start frame to find adjacent ones
            const sortedSegments = segments.slice().sort((a, b) => a.startFrame - b.startFrame);
            const currentSortedIndex = sortedSegments.findIndex(s => s === currentSegment);

            // Connect with previous segment
            if (currentSortedIndex > 0) {
                const prevSegment = sortedSegments[currentSortedIndex - 1];
                if (prevSegment.endFrame === currentSegment.startFrame) {
                    // Make values match at connection point
                    currentSegment.startValue = prevSegment.endValue;
                }
            }

            // Connect with next segment
            if (currentSortedIndex < sortedSegments.length - 1) {
                const nextSegment = sortedSegments[currentSortedIndex + 1];
                if (currentSegment.endFrame === nextSegment.startFrame) {
                    // Make values match at connection point
                    nextSegment.startValue = currentSegment.endValue;
                }
            }
        }

        function enforceExactAlignment(segments) {
            // Sort segments by start frame
            const sortedSegments = segments.slice().sort((a, b) => a.startFrame - b.startFrame);

            // Force exact frame alignment for segments that should be connected
            for (let i = 0; i < sortedSegments.length - 1; i++) {
                const currentSegment = sortedSegments[i];
                const nextSegment = sortedSegments[i + 1];

                // If segments are very close (within 2 frames), force them to connect exactly
                if (Math.abs(currentSegment.endFrame - nextSegment.startFrame) <= 2) {
                    // Choose the midpoint for exact alignment
                    const midFrame = Math.round((currentSegment.endFrame + nextSegment.startFrame) / 2);
                    currentSegment.endFrame = midFrame;
                    nextSegment.startFrame = midFrame;

                    // Also align values at connection point
                    nextSegment.startValue = currentSegment.endValue;
                }
            }
        }

        function updateKeyframeProperty() {
            if (!selectedKeyframe) return;

            const segments = editorKeyframes[selectedKeyframe.property];
            const segment = segments[selectedKeyframe.index];

            const startFrameInput = document.getElementById('keyframeStartFrame');
            const endFrameInput = document.getElementById('keyframeEndFrame');
            const startValueInput = document.getElementById('keyframeStartValue');
            const endValueInput = document.getElementById('keyframeEndValue');
            const easingInput = document.getElementById('keyframeEasing');

            // Get proposed new values
            let newStartFrame = startFrameInput ? parseInt(startFrameInput.value) : segment.startFrame;
            let newEndFrame = endFrameInput ? parseInt(endFrameInput.value) : segment.endFrame;

            // Apply snapping to connect adjacent segments
            const snappedFrames = snapToAdjacentSegments(segments, selectedKeyframe.index, newStartFrame, newEndFrame);
            newStartFrame = snappedFrames.startFrame;
            newEndFrame = snappedFrames.endFrame;

            // Validate that the segment doesn't overlap with others
            if (!isSegmentValid(segments, selectedKeyframe.index, newStartFrame, newEndFrame)) {
                // Reset to current values if invalid
                if (startFrameInput) startFrameInput.value = segment.startFrame;
                if (endFrameInput) endFrameInput.value = segment.endFrame;
                alert('Segments cannot overlap! They can only touch at start/end frames.');
                return;
            }

            // Update the segment with validated and snapped values
            if (startFrameInput) {
                segment.startFrame = newStartFrame;
                startFrameInput.value = newStartFrame; // Update UI to show snapped value
            }
            if (endFrameInput) {
                segment.endFrame = newEndFrame;
                endFrameInput.value = newEndFrame; // Update UI to show snapped value
            }
            if (startValueInput) segment.startValue = parseFloat(startValueInput.value);
            if (endValueInput) segment.endValue = parseFloat(endValueInput.value);

            if (easingInput) {
                const easingValues = easingInput.value.split(',').map(v => parseFloat(v.trim()));
                if (easingValues.length === 4 && easingValues.every(v => !isNaN(v))) {
                    segment.easing = easingValues;
                }
            }

            // Apply automatic value matching for connected segments
            connectAdjacentSegmentValues(segments, selectedKeyframe.index);

            // Enforce exact alignment for close segments
            enforceExactAlignment(segments);

            // Re-sort segments by start frame to maintain chronological order
            editorKeyframes[selectedKeyframe.property].sort((a, b) => a.startFrame - b.startFrame);

            renderKeyframes();

            // Find and reselect the segment after sorting
            const newIndex = editorKeyframes[selectedKeyframe.property].findIndex(s => s === segment);
            if (newIndex !== -1) {
                selectKeyframe(selectedKeyframe.property, newIndex);
            }
            updateCurrentFrameValues();
        }

        // Curve Preview Functions
        function showCurvePreview(event, bezierValues, title) {
            console.log('showCurvePreview called:', title, bezierValues); // Debug log

            if (bezierValues.length !== 4) {
                console.log('Invalid bezier values length:', bezierValues.length);
                return;
            }

            curveTitle.textContent = title;
            updateCurveDisplay(bezierValues);

            // Smart positioning - left side preferred, with fallbacks
            const rect = event.target.getBoundingClientRect();
            const previewWidth = 144; // Approximate width of preview (120px + padding)
            const previewHeight = 120; // Approximate height
            const gap = 10;

            let left, top;

            // Try left side first
            if (rect.left - previewWidth - gap >= 0) {
                left = rect.left - previewWidth - gap;
            }
            // If not enough space on left, try right side
            else if (rect.right + previewWidth + gap <= window.innerWidth) {
                left = rect.right + gap;
            }
            // If neither side works, center it and position above/below
            else {
                left = Math.max(gap, Math.min(window.innerWidth - previewWidth - gap, rect.left - previewWidth/2));
            }

            // Vertical positioning
            if (rect.top - previewHeight - gap >= 0) {
                top = rect.top - previewHeight - gap; // Above
            } else {
                top = rect.bottom + gap; // Below
            }

            // Ensure it doesn't go off-screen
            top = Math.max(gap, Math.min(window.innerHeight - previewHeight - gap, top));

            console.log('Smart positioning preview at:', left, top); // Debug log

            curvePreview.style.display = 'block';
            curvePreview.style.left = left + 'px';
            curvePreview.style.top = top + 'px';
            curvePreview.style.position = 'fixed';

            // Force a reflow then add show class
            curvePreview.offsetHeight;
            curvePreview.classList.add('show');
            console.log('Preview should be visible now'); // Debug log
        }

        function hideCurvePreview() {
            console.log('Hiding curve preview'); // Debug log
            curvePreview.classList.remove('show');

            // Hide after transition completes
            setTimeout(() => {
                if (!curvePreview.classList.contains('show')) {
                    curvePreview.style.display = 'none';
                }
            }, 200);
        }

                                function showKeyframeTooltip(event, property, index, segment) {
            const tooltip = document.getElementById('keyframeTooltip') || createKeyframeTooltip();

            const propertyInfo = {
                brightness: { name: 'Brightness', unit: '%' },
                rotation: { name: 'Rotation', unit: '¬∞' },
                tilt: { name: 'Tilt', unit: '¬∞' }
            };

            const info = propertyInfo[property];

            tooltip.innerHTML = `
                <strong>${info.name} Segment</strong><br>
                Frame ${segment.startFrame} ‚Üí ${segment.endFrame}<br>
                Value ${segment.startValue}${info.unit} ‚Üí ${segment.endValue}${info.unit}
            `;

            const rect = event.target.getBoundingClientRect();
            tooltip.style.left = (rect.left + rect.width / 2) + 'px';
            tooltip.style.top = (rect.top - 10) + 'px';
            tooltip.style.display = 'block';

            setTimeout(() => tooltip.classList.add('show'), 10);
        }

        function hideKeyframeTooltip() {
            const tooltip = document.getElementById('keyframeTooltip');
            if (tooltip) {
                tooltip.classList.remove('show');
                setTimeout(() => {
                    if (!tooltip.classList.contains('show')) {
                        tooltip.style.display = 'none';
                    }
                }, 200);
            }
        }

        function createKeyframeTooltip() {
            const tooltip = document.createElement('div');
            tooltip.id = 'keyframeTooltip';
            tooltip.className = 'keyframe-tooltip';
            document.body.appendChild(tooltip);
            return tooltip;
        }

        function updateCurveDisplay(bezierValues) {
            const [p1x, p1y, p2x, p2y] = bezierValues;

            // Convert bezier values (0-1) to SVG coordinates
            // SVG: 10,70 (bottom-left) to 90,10 (top-right)
            const x1 = 10 + (p1x * 80);
            const y1 = 70 - (p1y * 60);
            const x2 = 10 + (p2x * 80);
            const y2 = 70 - (p2y * 60);

            // Update control point positions
            handle1.setAttribute('cx', x1);
            handle1.setAttribute('cy', y1);
            handle2.setAttribute('cx', x2);
            handle2.setAttribute('cy', y2);

            // Generate cubic bezier curve path
            const pathData = `M 10,70 C ${x1},${y1} ${x2},${y2} 90,10`;
            curvePath.setAttribute('d', pathData);
        }

        // Add hover preview to custom easing input
        function addCustomEasingPreview() {
            const easingInput = document.getElementById('keyframeEasing');
            if (!easingInput) return;

            let previewTimeout;

            easingInput.addEventListener('mouseenter', (e) => {
                clearTimeout(previewTimeout);
                previewTimeout = setTimeout(() => {
                    const value = easingInput.value;
                    const easingValues = value.split(',').map(v => parseFloat(v.trim()));
                    if (easingValues.length === 4 && easingValues.every(v => !isNaN(v))) {
                        showCurvePreview(e, easingValues, 'Custom');
                    }
                }, 500); // Delay to avoid showing on quick mouse pass
            });

            easingInput.addEventListener('mouseleave', () => {
                clearTimeout(previewTimeout);
                hideCurvePreview();
            });
        }

                function loadDefaultKeyframes() {
            // Load some default keyframes as independent, non-overlapping segments
            editorKeyframes = {
                brightness: [
                    {
                        startFrame: 0, endFrame: 100,
                        startValue: 0, endValue: 100,
                        easing: [0.42, 0.0, 0.58, 1.0]
                    },
                    {
                        startFrame: 100, endFrame: 200,
                        startValue: 100, endValue: 0,
                        easing: [0.42, 0.0, 1.0, 1.0]
                    }
                ],
                rotation: [
                    {
                        startFrame: 0, endFrame: 70,
                        startValue: 180, endValue: 0,
                        easing: [0.42, 0.0, 0.58, 1.0]
                    },
                    {
                        startFrame: 70, endFrame: 150,
                        startValue: 0, endValue: 359,
                        easing: [0.42, 0.0, 1.0, 1.0]
                    },
                    {
                        startFrame: 150, endFrame: 200,
                        startValue: 359, endValue: 180,
                        easing: [0.42, 0.0, 1.0, 1.0]
                    }
                ],
                tilt: [
                    {
                        startFrame: 0, endFrame: 100,
                        startValue: 0, endValue: 30,
                        easing: [0.42, 0.0, 0.58, 1.0]
                    },
                    {
                        startFrame: 100, endFrame: 200,
                        startValue: 30, endValue: 0,
                        easing: [0.42, 0.0, 1.0, 1.0]
                    }
                ]
            };

            // Enforce alignment for all properties
            Object.keys(editorKeyframes).forEach(property => {
                enforceExactAlignment(editorKeyframes[property]);
            });

            renderKeyframes();
            updateCurrentFrameValues();
        }

        function loadAnimationFromParent(animationData) {
            console.log('Loading animation from parent:', animationData);

            // Load animation data from parent viewer into editor format
            if (animationData.frameRate) {
                editorFrameRate.value = animationData.frameRate;
            }
            if (animationData.startFrame !== undefined) {
                editorStartFrame.value = animationData.startFrame;
            }
            if (animationData.endFrame !== undefined) {
                editorEndFrame.value = animationData.endFrame;
            }
            if (animationData.loop !== undefined) {
                editorLoop.checked = animationData.loop;
            }

            // Convert animation properties to editor segment format
            editorKeyframes = {
                brightness: [],
                rotation: [],
                tilt: []
            };

            // Handle both formats:
            // 1. New format: animationData.properties[property] = array of segments
            // 2. Original format: animationData[property].keyframe = array of ranges

            Object.keys(editorKeyframes).forEach(property => {
                if (animationData.properties && animationData.properties[property]) {
                    // New format - direct segments
                    console.log(`Loading ${property} from new format:`, animationData.properties[property]);
                    const segments = animationData.properties[property];
                    editorKeyframes[property] = segments.map(segment => ({
                        startFrame: segment.startFrame,
                        endFrame: segment.endFrame,
                        startValue: segment.startValue,
                        endValue: segment.endValue,
                        easing: segment.easing || [0.42, 0.0, 0.58, 1.0]
                    }));
                } else if (animationData[property] && animationData[property].keyframe) {
                    // Original format - convert from ranges to segments
                    console.log(`Loading ${property} from original format:`, animationData[property].keyframe);
                    const ranges = animationData[property].keyframe;

                    editorKeyframes[property] = ranges.map(range => ({
                        startFrame: range.from_frame,
                        endFrame: range.to_frame,
                        startValue: range.from_value,
                        endValue: range.to_value,
                        easing: range.bezier || [0.42, 0.0, 0.58, 1.0]
                    }));

                    console.log(`Converted ${property} segments:`, editorKeyframes[property]);
                } else {
                    console.log(`No keyframes found for ${property}`);
                }
            });

            // Enforce alignment for all loaded properties
            Object.keys(editorKeyframes).forEach(property => {
                enforceExactAlignment(editorKeyframes[property]);
            });

            // Mark that we've loaded from parent
            hasLoadedFromParent = true;

            // Update UI with loaded data
            editorCurrentFrame = parseInt(editorStartFrame.value);
            updateTimelineConfig();
            renderKeyframes();
            updateCurrentFrameValues();
        }

        function playEditorAnimation() {
            editorIsPlaying = true;
            editorStartTime = Date.now() - (editorCurrentFrame / parseInt(editorFrameRate.value) * 1000);

            if (!editorAnimationId) {
                animateEditor();
            }
        }

        function pauseEditorAnimation() {
            editorIsPlaying = false;
            if (editorAnimationId) {
                cancelAnimationFrame(editorAnimationId);
                editorAnimationId = null;
            }
        }

        function resetEditorAnimation() {
            pauseEditorAnimation();
            editorCurrentFrame = parseInt(editorStartFrame.value);
            updatePlayhead();
        }

        function animateEditor() {
            if (editorIsPlaying) {
                const elapsed = Date.now() - editorStartTime;
                const frameRate = parseInt(editorFrameRate.value);
                const startFrame = parseInt(editorStartFrame.value);
                const endFrame = parseInt(editorEndFrame.value);

                editorCurrentFrame = startFrame + Math.floor(elapsed / (1000 / frameRate));

                if (editorCurrentFrame > endFrame) {
                    if (editorLoop.checked) {
                        editorCurrentFrame = startFrame;
                        editorStartTime = Date.now();
                    } else {
                        editorCurrentFrame = endFrame;
                        pauseEditorAnimation();
                    }
                }

                updatePlayhead();
                editorAnimationId = requestAnimationFrame(animateEditor);
            }
        }

                function updatePlayhead() {
            const startFrame = parseInt(editorStartFrame.value);
            const trackLabelWidth = 120; // Width of track labels
            const left = trackLabelWidth + (editorCurrentFrame - startFrame) * pixelsPerFrame;
            playhead.style.left = left + 'px';

            // Update frame display
            playheadFrameDisplay.textContent = `Frame ${editorCurrentFrame}`;

            // Update current property values
            updateCurrentFrameValues();
        }

        function updateCurrentFrameValues() {
            const brightness = interpolatePropertyValue('brightness', editorCurrentFrame);
            const rotation = interpolatePropertyValue('rotation', editorCurrentFrame);
            const tilt = interpolatePropertyValue('tilt', editorCurrentFrame);

            trackBrightness.textContent = `${Math.round(brightness)}%`;
            trackRotation.textContent = `${Math.round(rotation)}¬∞`;
            trackTilt.textContent = `${Math.round(tilt)}¬∞`;

            // Send live property updates to main viewer during playback
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'livePropertyUpdate',
                    properties: {
                        brightness: brightness,
                        rotation: rotation,
                        tilt: tilt
                    }
                }, '*');
            }
        }

        function interpolatePropertyValue(property, frame) {
            const segments = editorKeyframes[property];

            if (segments.length === 0) {
                // Return default values if no segments
                const defaults = { brightness: 50, rotation: 180, tilt: 0 };
                return defaults[property];
            }

            // Sort segments by start frame to ensure proper order
            const sortedSegments = segments.slice().sort((a, b) => a.startFrame - b.startFrame);

            // Find the segment that contains this frame
            for (let i = 0; i < sortedSegments.length; i++) {
                const segment = sortedSegments[i];

                // Check if frame is within this segment
                if (frame >= segment.startFrame && frame <= segment.endFrame) {
                    // If frame exactly matches start frame
                    if (frame === segment.startFrame) {
                        return segment.startValue;
                    }

                    // If frame exactly matches end frame
                    if (frame === segment.endFrame) {
                        return segment.endValue;
                    }

                    // Interpolate within the segment
                    const totalFrames = segment.endFrame - segment.startFrame;
                    const currentProgress = frame - segment.startFrame;
                    let t = currentProgress / totalFrames;

                    // Apply easing curve
                    if (segment.easing && segment.easing.length === 4) {
                        t = cubicBezier(t, segment.easing[0], segment.easing[1],
                                           segment.easing[2], segment.easing[3]);
                    }

                    // Linear interpolation with easing
                    return segment.startValue + (segment.endValue - segment.startValue) * t;
                }
            }

            // If frame is before all segments, return the start value of the first segment
            if (frame < sortedSegments[0].startFrame) {
                return sortedSegments[0].startValue;
            }

            // If frame is after all segments, return the end value of the last segment
            if (frame > sortedSegments[sortedSegments.length - 1].endFrame) {
                return sortedSegments[sortedSegments.length - 1].endValue;
            }

            // Handle gaps between segments - hold the last value
            // Find the last segment that ended before or at this frame
            let lastCompletedSegment = null;
            for (let i = 0; i < sortedSegments.length; i++) {
                const segment = sortedSegments[i];
                if (segment.endFrame < frame) {
                    lastCompletedSegment = segment;
                } else {
                    break; // We've reached a segment that starts after our frame
                }
            }

            if (lastCompletedSegment) {
                // Hold the end value of the last completed segment
                return lastCompletedSegment.endValue;
            }

            // Fallback - if no previous segment found, return start value of next segment
            for (let i = 0; i < sortedSegments.length; i++) {
                const segment = sortedSegments[i];
                if (segment.startFrame > frame) {
                    return segment.startValue;
                }
            }

            // Final fallback to default values
            const defaults = { brightness: 50, rotation: 180, tilt: 0 };
            return defaults[property];
        }

        function cubicBezier(t, p1x, p1y, p2x, p2y) {
            const cx = 3 * p1x;
            const bx = 3 * (p2x - p1x) - cx;
            const ax = 1 - cx - bx;
            const cy = 3 * p1y;
            const by = 3 * (p2y - p1y) - cy;
            const ay = 1 - cy - by;

            const sampleCurveY = (t) => ((ay * t + by) * t + cy) * t;
            return sampleCurveY(t);
        }

        function startDragPlayhead(event) {
            event.preventDefault();
            isDraggingPlayhead = true;
            dragStartX = event.clientX;
            dragStartFrame = editorCurrentFrame;

            // Pause animation while dragging
            const wasPlaying = editorIsPlaying;
            pauseEditorAnimation();
            playheadHandle.dataset.wasPlaying = wasPlaying;
        }

        function dragPlayhead(event) {
            if (!isDraggingPlayhead) return;

            event.preventDefault();
            const deltaX = event.clientX - dragStartX;
            const deltaFrames = Math.round(deltaX / pixelsPerFrame);
            const newFrame = Math.max(
                parseInt(editorStartFrame.value),
                Math.min(
                    parseInt(editorEndFrame.value),
                    dragStartFrame + deltaFrames
                )
            );

            editorCurrentFrame = newFrame;
            updatePlayhead();
        }

        function stopDragPlayhead(event) {
            if (!isDraggingPlayhead) return;

            isDraggingPlayhead = false;

            // Resume animation if it was playing before drag
            if (playheadHandle.dataset.wasPlaying === 'true') {
                playEditorAnimation();
            }
        }

                function handleEditorKeydown(event) {
            // Don't interfere when user is typing in input fields
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;

            switch (event.key) {
                case ' ': // Spacebar
                    event.preventDefault(); // Prevent page scroll
                    toggleEditorPlayback();
                    break;
                case 'Home':
                    event.preventDefault();
                    jumpToStart();
                    break;
                case 'End':
                    event.preventDefault();
                    jumpToEnd();
                    break;
                case 'ArrowLeft':
                    if (event.shiftKey) {
                        event.preventDefault();
                        jumpToPreviousKeyframe();
                    } else {
                        event.preventDefault();
                        stepFrame(-1);
                    }
                    break;
                case 'ArrowRight':
                    if (event.shiftKey) {
                        event.preventDefault();
                        jumpToNextKeyframe();
                    } else {
                        event.preventDefault();
                        stepFrame(1);
                    }
                    break;
                case 'Escape':
                    event.preventDefault();
                    closeEditor();
                    break;
                case 'Delete':
                case 'Backspace':
                    event.preventDefault();
                    deleteSelectedKeyframe();
                    break;
            }
        }

        function toggleEditorPlayback() {
            if (editorIsPlaying) {
                pauseEditorAnimation();
            } else {
                playEditorAnimation();
            }
        }

        function jumpToStart() {
            pauseEditorAnimation();
            editorCurrentFrame = parseInt(editorStartFrame.value);
            updatePlayhead();
        }

        function jumpToEnd() {
            pauseEditorAnimation();
            editorCurrentFrame = parseInt(editorEndFrame.value);
            updatePlayhead();
        }

        function stepFrame(direction) {
            pauseEditorAnimation();
            const startFrame = parseInt(editorStartFrame.value);
            const endFrame = parseInt(editorEndFrame.value);
            editorCurrentFrame = Math.max(startFrame, Math.min(endFrame, editorCurrentFrame + direction));
            updatePlayhead();
        }

        function jumpToPreviousKeyframe() {
            pauseEditorAnimation();

            // Collect all segment frames and sort by frame
            const allFrames = [];
            Object.keys(editorKeyframes).forEach(property => {
                editorKeyframes[property].forEach(segment => {
                    allFrames.push(segment.startFrame);
                    allFrames.push(segment.endFrame);
                });
            });

            const uniqueFrames = [...new Set(allFrames)].sort((a, b) => a - b);
            const currentIndex = uniqueFrames.findIndex(frame => frame >= editorCurrentFrame);

            if (currentIndex > 0) {
                editorCurrentFrame = uniqueFrames[currentIndex - 1];
            } else if (uniqueFrames.length > 0) {
                editorCurrentFrame = uniqueFrames[uniqueFrames.length - 1]; // Wrap to last
            }

            updatePlayhead();
        }

        function jumpToNextKeyframe() {
            pauseEditorAnimation();

            // Collect all segment frames and sort by frame
            const allFrames = [];
            Object.keys(editorKeyframes).forEach(property => {
                editorKeyframes[property].forEach(segment => {
                    allFrames.push(segment.startFrame);
                    allFrames.push(segment.endFrame);
                });
            });

            const uniqueFrames = [...new Set(allFrames)].sort((a, b) => a - b);
            const nextFrame = uniqueFrames.find(frame => frame > editorCurrentFrame);

            if (nextFrame !== undefined) {
                editorCurrentFrame = nextFrame;
            } else if (uniqueFrames.length > 0) {
                editorCurrentFrame = uniqueFrames[0]; // Wrap to first
            }

            updatePlayhead();
        }

        async function exportAnimationJson() {
            const animationConfig = {
                frameRate: parseInt(editorFrameRate.value),
                startFrame: parseInt(editorStartFrame.value),
                endFrame: parseInt(editorEndFrame.value),
                loop: editorLoop.checked
            };

            // Convert editor segments to JSON format
            Object.keys(editorKeyframes).forEach(property => {
                if (editorKeyframes[property].length > 0) {
                    const segments = editorKeyframes[property];
                    const jsonKeyframes = segments.map(segment => ({
                        from_frame: segment.startFrame,
                        to_frame: segment.endFrame,
                        from_value: segment.startValue,
                        to_value: segment.endValue,
                        bezier: segment.easing
                    }));

                    animationConfig[property] = {
                        animation: true,
                        keyframe: jsonKeyframes
                    };
                }
            });

            const jsonString = JSON.stringify(animationConfig, null, 2);

            // Try to use File System Access API for modern browsers
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: 'custom_animation.json',
                        types: [
                            {
                                description: 'JSON files',
                                accept: {
                                    'application/json': ['.json'],
                                },
                            },
                        ],
                    });

                    const writable = await fileHandle.createWritable();
                    await writable.write(jsonString);
                    await writable.close();

                    console.log('Animation exported successfully!');
                    return;
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.error('Error saving file:', error);
                    }
                    // Fall through to download method if save dialog was cancelled or failed
                }
            }

            // Fallback: Download the JSON file (for older browsers or if save picker failed)
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = 'custom_animation.json';
            downloadLink.style.display = 'none';

            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);

            URL.revokeObjectURL(url);
        }

                function loadToViewer() {
            const animationConfig = {
                frameRate: parseInt(editorFrameRate.value),
                startFrame: parseInt(editorStartFrame.value),
                endFrame: parseInt(editorEndFrame.value),
                loop: editorLoop.checked
            };

            // Convert editor segments to JSON format
            Object.keys(editorKeyframes).forEach(property => {
                if (editorKeyframes[property].length > 0) {
                    const segments = editorKeyframes[property];
                    const jsonKeyframes = segments.map(segment => ({
                        from_frame: segment.startFrame,
                        to_frame: segment.endFrame,
                        from_value: segment.startValue,
                        to_value: segment.endValue,
                        bezier: segment.easing
                    }));

                    animationConfig[property] = {
                        animation: true,
                        keyframe: jsonKeyframes
                    };
                }
            });

            // Check if we're in an iframe
            if (window.parent !== window) {
                // Send message to parent frame
                window.parent.postMessage({
                    type: 'loadAnimation',
                    animation: animationConfig
                }, '*');
            } else {
                // Fallback: store in localStorage and open new window
                localStorage.setItem('editorAnimation', JSON.stringify(animationConfig));
                window.open('index.html', '_blank');
            }
        }

        // Close editor function
        function closeEditor() {
            if (window.parent !== window) {
                // In iframe - tell parent to close
                window.parent.postMessage({
                    type: 'closeEditor'
                }, '*');
            } else {
                // Standalone window - close it
                window.close();
            }
        }

        // Initialize the editor when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>